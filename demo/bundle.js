var VGM =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./dist/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./dist/builder.js":
/*!*************************!*\
  !*** ./dist/builder.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar AutoResizeBuffer = /** @class */ (function () {\n    function AutoResizeBuffer() {\n        this._buf = new ArrayBuffer(256);\n        this._view = new DataView(this._buf);\n        this._written = 0;\n    }\n    AutoResizeBuffer.prototype._expandBuffer = function () {\n        var newSize = this._buf.byteLength * 2;\n        var newBuf = new ArrayBuffer(newSize);\n        new Uint8Array(newBuf).set(new Uint8Array(this._buf));\n        this._buf = newBuf;\n        this._view = new DataView(this._buf);\n    };\n    AutoResizeBuffer.prototype.toArrayBuffer = function () {\n        return this._buf.slice(0, this._written);\n    };\n    AutoResizeBuffer.prototype.setUint8 = function (byteOffset, value) {\n        if (this._view.byteLength < byteOffset + 1) {\n            this._expandBuffer();\n        }\n        this._view.setUint8(byteOffset, value);\n        this._written = Math.max(this._written, byteOffset + 1);\n    };\n    AutoResizeBuffer.prototype.setInt8 = function (byteOffset, value) {\n        if (this._view.byteLength < byteOffset + 1) {\n            this._expandBuffer();\n        }\n        this._view.setInt8(byteOffset, value);\n        this._written = Math.max(this._written, byteOffset + 1);\n    };\n    AutoResizeBuffer.prototype.setUint16LE = function (byteOffset, value) {\n        if (this._view.byteLength < byteOffset + 2) {\n            this._expandBuffer();\n        }\n        this._view.setUint16(byteOffset, value, true);\n        this._written = Math.max(this._written, byteOffset + 2);\n    };\n    AutoResizeBuffer.prototype.setInt16LE = function (byteOffset, value) {\n        if (this._view.byteLength < byteOffset + 2) {\n            this._expandBuffer();\n        }\n        this._view.setInt16(byteOffset, value, true);\n        this._written = Math.max(this._written, byteOffset + 2);\n    };\n    AutoResizeBuffer.prototype.setUint32LE = function (byteOffset, value) {\n        if (this._view.byteLength < byteOffset + 4) {\n            this._expandBuffer();\n        }\n        this._view.setUint32(byteOffset, value, true);\n        this._written = Math.max(this._written, byteOffset + 4);\n    };\n    AutoResizeBuffer.prototype.setInt32LE = function (byteOffset, value) {\n        if (this._view.byteLength < byteOffset + 4) {\n            this._expandBuffer();\n        }\n        this._view.setInt32(byteOffset, value, true);\n        this._written = Math.max(this._written, byteOffset + 4);\n    };\n    AutoResizeBuffer.prototype.setData = function (byteOffset, data) {\n        while (this._view.byteLength < byteOffset + data.length) {\n            this._expandBuffer();\n        }\n        for (var i = 0; i < data.length; i++) {\n            this._view.setUint8(byteOffset + i, data[i]);\n        }\n        this._written = Math.max(this._written, byteOffset + data.length);\n    };\n    AutoResizeBuffer.prototype.setText = function (byteOffset, text) {\n        while (this._view.byteLength < byteOffset + (text.length * 2 + 2)) {\n            this._expandBuffer();\n        }\n        for (var i = 0; i < text.length; i++) {\n            this.setUint16LE(byteOffset + i * 2, text.charCodeAt(i));\n        }\n        this.setUint16LE(byteOffset + text.length * 2, 0);\n        return text.length * 2 + 2;\n    };\n    return AutoResizeBuffer;\n}());\nexports.AutoResizeBuffer = AutoResizeBuffer;\nfunction _makeClock(obj) {\n    return obj.clock | (obj.dual ? 0x40000000 : 0);\n}\nfunction _writeVGMHeader(buf, vgm) {\n    buf.setUint8(0x00, 0x56); // 'V'\n    buf.setUint8(0x01, 0x67); // 'g'\n    buf.setUint8(0x02, 0x6d); // 'm'\n    buf.setUint8(0x03, 0x20); // ' '\n    buf.setUint32LE(0x04, vgm.offsets.eof - 0x04);\n    buf.setUint32LE(0x08, vgm.version.code);\n    buf.setUint32LE(0x14, 0 < vgm.offsets.gd3 ? vgm.offsets.gd3 - 0x14 : 0);\n    buf.setUint32LE(0x18, vgm.samples.total);\n    buf.setUint32LE(0x1c, 0 < vgm.samples.loop ? vgm.offsets.loop - 0x1c : 0);\n    buf.setUint32LE(0x20, vgm.samples.loop);\n    buf.setUint32LE(0x34, vgm.offsets.data - 0x34);\n    if (vgm.chips.sn76489) {\n        buf.setUint32LE(0x0c, _makeClock(vgm.chips.sn76489) | (vgm.chips.sn76489.t6w28 ? 0x80000000 : 0));\n    }\n    if (vgm.chips.ym2413) {\n        buf.setUint32LE(0x10, _makeClock(vgm.chips.ym2413));\n    }\n    if (0x101 <= vgm.version.code) {\n        buf.setUint32LE(0x24, vgm.rate);\n    }\n    if (0x110 <= vgm.version.code) {\n        if (vgm.chips.sn76489) {\n            buf.setUint16LE(0x28, vgm.chips.sn76489.feedback || 0);\n            buf.setUint8(0x2a, vgm.chips.sn76489.shiftRegisterWidth || 0);\n        }\n        if (vgm.chips.ym2612) {\n            buf.setUint32LE(0x2c, _makeClock(vgm.chips.ym2612));\n        }\n        if (vgm.chips.ym2151) {\n            buf.setUint32LE(0x30, _makeClock(vgm.chips.ym2151));\n        }\n    }\n    if (0x150 <= vgm.version.code) {\n        buf.setUint32LE(0x34, (vgm.offsets.data || 0x40) - 0x34);\n    }\n    if (0x151 <= vgm.version.code) {\n        if (vgm.chips.sn76489) {\n            buf.setUint8(0x2b, vgm.chips.sn76489.flags || 0);\n        }\n        if (vgm.chips.segaPcm) {\n            buf.setUint32LE(0x38, _makeClock(vgm.chips.segaPcm));\n            buf.setUint32LE(0x3c, vgm.chips.segaPcm.interfaceRegister || 0);\n        }\n        if (vgm.chips.rf5c68) {\n            buf.setUint32LE(0x40, _makeClock(vgm.chips.rf5c68));\n        }\n        if (vgm.chips.ym2203) {\n            buf.setUint32LE(0x44, _makeClock(vgm.chips.ym2203));\n        }\n        if (vgm.chips.ym2608) {\n            buf.setUint32LE(0x48, _makeClock(vgm.chips.ym2608));\n        }\n        if (vgm.chips.ym2610) {\n            var chipType = vgm.chips.ym2610.chipType || { value: 0 };\n            buf.setUint32LE(0x4c, _makeClock(vgm.chips.ym2610) | (chipType.value ? 0x80000000 : 0));\n        }\n        if (vgm.chips.ym3812) {\n            buf.setUint32LE(0x50, _makeClock(vgm.chips.ym3812));\n        }\n        if (vgm.chips.ym3526) {\n            buf.setUint32LE(0x54, _makeClock(vgm.chips.ym3526));\n        }\n        if (vgm.chips.y8950) {\n            buf.setUint32LE(0x58, _makeClock(vgm.chips.y8950));\n        }\n        if (vgm.chips.ymf262) {\n            buf.setUint32LE(0x5c, _makeClock(vgm.chips.ymf262));\n        }\n        if (vgm.chips.ymf278b) {\n            buf.setUint32LE(0x60, _makeClock(vgm.chips.ymf278b));\n        }\n        if (vgm.chips.ymf271) {\n            buf.setUint32LE(0x64, _makeClock(vgm.chips.ymf271));\n        }\n        if (vgm.chips.ymz280b) {\n            buf.setUint32LE(0x68, _makeClock(vgm.chips.ymz280b));\n        }\n        if (vgm.chips.rf5c164) {\n            buf.setUint32LE(0x6c, _makeClock(vgm.chips.rf5c164));\n        }\n        if (vgm.chips.pwm) {\n            buf.setUint32LE(0x70, _makeClock(vgm.chips.pwm));\n        }\n        if (vgm.chips.ay8910) {\n            buf.setUint32LE(0x74, _makeClock(vgm.chips.ay8910));\n            var chipType = vgm.chips.ay8910.chipType || { value: 0 };\n            buf.setUint8(0x78, chipType.value);\n            buf.setUint8(0x79, vgm.chips.ay8910.flags || 0);\n        }\n        if (vgm.chips.ym2203) {\n            buf.setUint8(0x7a, vgm.chips.ym2203.ssgFlags || 0);\n        }\n        if (vgm.chips.ym2608) {\n            buf.setUint8(0x7b, vgm.chips.ym2608.ssgFlags || 0);\n        }\n        buf.setUint8(0x7f, vgm.loopModifier);\n    }\n    if (0x160 <= vgm.version.code) {\n        buf.setUint8(0x7c, vgm.volumeModifier);\n        buf.setUint8(0x7e, vgm.loopBase);\n    }\n    if (0x161 <= vgm.version.code) {\n        if (vgm.chips.gameBoyDmg) {\n            buf.setUint32LE(0x80, _makeClock(vgm.chips.gameBoyDmg));\n        }\n        if (vgm.chips.nesApu) {\n            buf.setUint32LE(0x84, _makeClock(vgm.chips.nesApu) | (vgm.chips.nesApu.fds ? 0x80000000 : 0));\n        }\n        if (vgm.chips.multiPcm) {\n            buf.setUint32LE(0x88, _makeClock(vgm.chips.multiPcm));\n        }\n        if (vgm.chips.upd7759) {\n            buf.setUint32LE(0x8c, _makeClock(vgm.chips.upd7759));\n        }\n        if (vgm.chips.okim6258) {\n            buf.setUint32LE(0x90, _makeClock(vgm.chips.okim6258));\n            buf.setUint8(0x94, vgm.chips.okim6258.flags || 0);\n        }\n        if (vgm.chips.k054539) {\n            buf.setUint8(0x95, vgm.chips.k054539.flags || 0);\n        }\n        if (vgm.chips.c140) {\n            var chipType = vgm.chips.c140.chipType || { value: 0 };\n            buf.setUint8(0x96, chipType.value);\n        }\n        if (vgm.chips.okim6295) {\n            buf.setUint32LE(0x98, _makeClock(vgm.chips.okim6295));\n        }\n        if (vgm.chips.k051649) {\n            buf.setUint32LE(0x9c, _makeClock(vgm.chips.k051649));\n        }\n        if (vgm.chips.k054539) {\n            buf.setUint32LE(0xa0, _makeClock(vgm.chips.k054539));\n        }\n        if (vgm.chips.huc6280) {\n            buf.setUint32LE(0xa4, _makeClock(vgm.chips.huc6280));\n        }\n        if (vgm.chips.c140) {\n            buf.setUint32LE(0xa8, _makeClock(vgm.chips.c140));\n        }\n        if (vgm.chips.k053260) {\n            buf.setUint32LE(0xac, _makeClock(vgm.chips.k053260));\n        }\n        if (vgm.chips.pokey) {\n            buf.setUint32LE(0x0b0, _makeClock(vgm.chips.pokey));\n        }\n        if (vgm.chips.qsound) {\n            buf.setUint32LE(0xb4, _makeClock(vgm.chips.qsound));\n        }\n    }\n    if (0x170 <= vgm.version.code) {\n        buf.setUint32LE(0xbc, vgm.offsets.extraHeader ? vgm.offsets.extraHeader - 0xbc : 0);\n        if (vgm.extraHeader) {\n            _writeExtraHeader(buf, vgm.offsets.extraHeader, vgm.extraHeader);\n        }\n    }\n    if (0x171 <= vgm.version.code) {\n        if (vgm.chips.scsp) {\n            buf.setUint32LE(0xb8, _makeClock(vgm.chips.scsp));\n        }\n        if (vgm.chips.wonderSwan) {\n            buf.setUint32LE(0xc0, _makeClock(vgm.chips.wonderSwan));\n        }\n        if (vgm.chips.vsu) {\n            buf.setUint32LE(0x0c4, _makeClock(vgm.chips.vsu));\n        }\n        if (vgm.chips.saa1099) {\n            buf.setUint32LE(0xc8, _makeClock(vgm.chips.saa1099));\n        }\n        if (vgm.chips.es5503) {\n            buf.setUint32LE(0xcc, _makeClock(vgm.chips.es5503));\n        }\n        if (vgm.chips.es5506) {\n            var chipType = vgm.chips.es5506.chipType || { value: 0 };\n            buf.setUint32LE(0xd0, _makeClock(vgm.chips.es5506) | (chipType.value ? 0x80000000 : 0));\n        }\n        if (vgm.chips.es5503) {\n            buf.setUint8(0xd4, vgm.chips.es5503.numberOfChannels || 0);\n        }\n        if (vgm.chips.es5506) {\n            buf.setUint8(0xd5, vgm.chips.es5506.numberOfChannels || 0);\n        }\n        if (vgm.chips.c352) {\n            buf.setUint8(0xd6, vgm.chips.c352.clockDivider || 0);\n        }\n        if (vgm.chips.x1_010) {\n            buf.setUint32LE(0xd8, _makeClock(vgm.chips.x1_010));\n        }\n        if (vgm.chips.c352) {\n            buf.setUint32LE(0xdc, _makeClock(vgm.chips.c352));\n        }\n        if (vgm.chips.ga20) {\n            buf.setUint32LE(0xe0, _makeClock(vgm.chips.ga20));\n        }\n        buf.setUint32LE(0xe4, 0);\n    }\n    return vgm.version.code <= 0x100 ? 0x40 : vgm.offsets.data || 0x100;\n}\nfunction _writeExtraChipClocks(buf, byteOffset, clocks) {\n    var wp = 0;\n    buf.setUint8(byteOffset + wp, clocks.length);\n    wp++;\n    for (var _i = 0, clocks_1 = clocks; _i < clocks_1.length; _i++) {\n        var e = clocks_1[_i];\n        buf.setUint8(byteOffset + wp, e.chipId);\n        wp++;\n        buf.setUint32LE(byteOffset + wp, e.clock);\n        wp += 4;\n    }\n    return wp;\n}\nfunction _writeExtraChipVolumes(buf, byteOffset, volumes) {\n    var wp = 0;\n    buf.setUint8(byteOffset + wp, volumes.length);\n    wp++;\n    for (var _i = 0, volumes_1 = volumes; _i < volumes_1.length; _i++) {\n        var e = volumes_1[_i];\n        buf.setUint8(byteOffset + wp, e.chipId | (e.paired ? 0x80 : 0));\n        wp++;\n        buf.setUint8(byteOffset + wp, e.flags);\n        wp++;\n        buf.setUint16LE(byteOffset + wp, e.volume | (e.absolute ? 0x8000 : 0));\n        wp += 2;\n    }\n    return wp;\n}\nfunction _writeExtraHeader(buf, byteOffset, header) {\n    var headerSize = header.volumes ? 12 : 8;\n    buf.setUint32LE(byteOffset, headerSize);\n    var clockPartSize = 0, volumePartSize = 0;\n    if (header.clocks) {\n        clockPartSize = _writeExtraChipClocks(buf, byteOffset + headerSize, header.clocks);\n        buf.setUint32LE(byteOffset + 4, headerSize - 4);\n    }\n    if (header.volumes) {\n        volumePartSize = _writeExtraChipVolumes(buf, byteOffset + headerSize + clockPartSize, header.volumes);\n        buf.setUint32LE(byteOffset + 8, headerSize - 8 + clockPartSize);\n    }\n    return headerSize + clockPartSize + volumePartSize;\n}\nfunction _writeGD3Tag(buf, byteOffset, gd3) {\n    buf.setUint32LE(byteOffset + 0, 0x20336447);\n    buf.setUint32LE(byteOffset + 4, gd3.version || 0x100);\n    var wp = byteOffset + 12;\n    wp += buf.setText(wp, gd3.trackTitle);\n    wp += buf.setText(wp, gd3.japanese.trackTitle);\n    wp += buf.setText(wp, gd3.gameName);\n    wp += buf.setText(wp, gd3.japanese.gameName);\n    wp += buf.setText(wp, gd3.system);\n    wp += buf.setText(wp, gd3.japanese.system);\n    wp += buf.setText(wp, gd3.composer);\n    wp += buf.setText(wp, gd3.japanese.composer);\n    wp += buf.setText(wp, gd3.releaseDate);\n    wp += buf.setText(wp, gd3.vgmBy);\n    wp += buf.setText(wp, gd3.notes);\n    var size = wp - (byteOffset + 12);\n    buf.setUint32LE(byteOffset + 8, size);\n    return wp;\n}\nfunction buildVGMData(commands) {\n    var buf = new AutoResizeBuffer();\n    var wp = 0;\n    for (var _i = 0, commands_1 = commands; _i < commands_1.length; _i++) {\n        var cmd = commands_1[_i];\n        buf.setData(wp, cmd.toUint8Array());\n        wp += cmd.size;\n    }\n    return buf.toArrayBuffer();\n}\nexports.buildVGMData = buildVGMData;\nfunction buildVGM(vgm) {\n    var buf = new AutoResizeBuffer();\n    var wp = _writeVGMHeader(buf, vgm);\n    buf.setData(wp, new Uint8Array(vgm.data));\n    wp += vgm.data.byteLength;\n    if (vgm.gd3tag) {\n        _writeGD3Tag(buf, vgm.offsets.gd3 || wp, vgm.gd3tag);\n    }\n    return buf.toArrayBuffer();\n}\nexports.buildVGM = buildVGM;\n\n\n//# sourceURL=webpack://VGM/./dist/builder.js?");

/***/ }),

/***/ "./dist/index.js":
/*!***********************!*\
  !*** ./dist/index.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(/*! ./vgm_command */ \"./dist/vgm_command.js\"));\n__export(__webpack_require__(/*! ./vgm_object */ \"./dist/vgm_object.js\"));\n__export(__webpack_require__(/*! ./parser */ \"./dist/parser.js\"));\n__export(__webpack_require__(/*! ./builder */ \"./dist/builder.js\"));\n__export(__webpack_require__(/*! ./vgm */ \"./dist/vgm.js\"));\n\n\n//# sourceURL=webpack://VGM/./dist/index.js?");

/***/ }),

/***/ "./dist/parser.js":
/*!************************!*\
  !*** ./dist/parser.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @hidden\n * @internal\n */\nvar vgm_object_1 = __webpack_require__(/*! ./vgm_object */ \"./dist/vgm_object.js\");\n__webpack_require__(/*! util */ \"./node_modules/node-libs-browser/node_modules/util/util.js\"); // for node.js: load TextDecoder globally.\nvar Zlib = __webpack_require__(/*! zlibjs/bin/gunzip.min.js */ \"./node_modules/zlibjs/bin/gunzip.min.js\").Zlib;\n/** @hidden */\nfunction getParamsCommon(d, clockIndex) {\n    var clock = d.getUint32(clockIndex, true);\n    if (clock) {\n        return { clock: clock & 0x3fffffff, dual: clock & 0x40000000 ? true : false };\n    }\n    return undefined;\n}\n/** @hidden */\nfunction getParamsCommonWithFlags(d, clockIndex, flagsIndex) {\n    var clock = d.getUint32(clockIndex, true);\n    if (clock) {\n        return { clock: clock & 0x3fffffff, dual: clock & 0x40000000 ? true : false, flags: d.getUint8(flagsIndex) };\n    }\n    return undefined;\n}\n/** @hidden */\nfunction getParamsSn76489(d) {\n    var t6w28 = d.getUint8(0x0f) & 0x80 ? true : false;\n    var obj = getParamsCommonWithFlags(d, 0x0c, 0x2b);\n    if (obj) {\n        return __assign({}, obj, { feedback: d.getUint16(0x28, true), shiftRegisterWidth: d.getUint8(0x2a), t6w28: t6w28 });\n    }\n    return undefined;\n}\n/** @hidden */\nfunction getParamsSegaPcm(d) {\n    var obj = getParamsCommon(d, 0x38);\n    if (obj) {\n        return __assign({}, obj, { interfaceRegister: d.getUint32(0x3c, true) });\n    }\n    return undefined;\n}\n/** @hidden */\nfunction getParamsYm2151(d) {\n    var obj = getParamsCommon(d, 0x30);\n    if (obj) {\n        var t = obj.clock >> 30;\n        return __assign({}, obj, { clock: obj.clock & 0x7fffffff, chipType: {\n                value: t,\n                name: t ? \"YM2164\" : \"YM2151\"\n            } });\n    }\n    return undefined;\n}\n/** @hidden */\nfunction getParamsYm2203(d) {\n    var obj = getParamsCommon(d, 0x44);\n    if (obj) {\n        return __assign({}, obj, { ssgFlags: d.getUint8(0x7a) });\n    }\n    return undefined;\n}\n/** @hidden */\nfunction getParamsYm2608(d) {\n    var obj = getParamsCommon(d, 0x48);\n    if (obj) {\n        return __assign({}, obj, { ssgFlags: d.getUint8(0x7b) });\n    }\n    return undefined;\n}\n/** @hidden */\nfunction getParamsYm2610(d) {\n    var obj = getParamsCommon(d, 0x4c);\n    if (obj) {\n        var t = d.getUint8(0x4c);\n        return __assign({}, obj, { clock: obj.clock & 0x7fffffff, chipType: {\n                value: t,\n                name: t ? \"YM2610\" : \"YM2610B\"\n            } });\n    }\n    return undefined;\n}\n/** @hidden */\nfunction getParamsYm2612(d) {\n    var obj = getParamsCommon(d, 0x2c);\n    if (obj) {\n        var t = obj.clock >> 30;\n        return __assign({}, obj, { clock: obj.clock & 0x7fffffff, chipType: {\n                value: t,\n                name: t ? \"YM3438\" : \"YM2612\"\n            } });\n    }\n    return undefined;\n}\n/** @hidden */\nfunction getParamsNesApu(d) {\n    var obj = getParamsCommon(d, 0x84);\n    if (obj) {\n        return __assign({}, obj, { fds: d.getUint8(0x84) & 0x80 ? true : false });\n    }\n    return undefined;\n}\n/** @hidden */\nfunction getParamsEs5503(d) {\n    var obj = getParamsCommon(d, 0xcc);\n    if (obj) {\n        return __assign({}, obj, { numberOfChannels: d.getUint8(0xd4) });\n    }\n    return undefined;\n}\n/** @hidden */\nfunction getParamsEs5506(d) {\n    var obj = getParamsCommon(d, 0xd0);\n    if (obj) {\n        var t = obj.clock >> 30;\n        return __assign({}, obj, { clock: obj.clock & 0x7fffffff, chipType: {\n                value: t,\n                name: t ? \"ES5506\" : \"ES5505\"\n            }, numberOfChannels: d.getUint8(0xd5) });\n    }\n    return undefined;\n}\n/** @hidden */\nfunction getParamsAy8910(d) {\n    var obj = getParamsCommon(d, 0x74);\n    if (obj) {\n        var t = d.getUint8(0x78);\n        var flags = d.getUint8(0x79);\n        return __assign({}, obj, { chipType: {\n                value: t,\n                name: (function (t) {\n                    switch (t) {\n                        case 0x00:\n                            return \"AY8910\";\n                        case 0x01:\n                            return \"AY8912\";\n                        case 0x02:\n                            return \"AY8913\";\n                        case 0x03:\n                            return \"AY8930\";\n                        case 0x10:\n                            return \"YM2149\";\n                        case 0x11:\n                            return \"YM3439\";\n                        case 0x12:\n                            return \"YMZ284\";\n                        case 0x13:\n                            return \"YMZ294\";\n                        default:\n                            return \"UNKNOWN\";\n                    }\n                })(t)\n            }, flags: flags });\n    }\n    return undefined;\n}\n/** @hidden */\nfunction getParamsC140(d) {\n    var obj = getParamsCommon(d, 0xa8);\n    if (obj) {\n        var t = d.getUint8(0x96);\n        return __assign({}, obj, { chipType: {\n                value: t,\n                name: (function (t) {\n                    switch (t) {\n                        case 0x00:\n                            return \"C140, Namco System 2\";\n                        case 0x01:\n                            return \"C140, Namco System 21\";\n                        case 0x02:\n                            return \"219 ASIC, Namco NA-1/2\";\n                        default:\n                            return \"UNKNOWN\";\n                    }\n                })(t)\n            } });\n    }\n    return undefined;\n}\n/** @hidden */\nfunction getParamsC352(d) {\n    var obj = getParamsCommon(d, 0xdc);\n    if (obj) {\n        return __assign({}, obj, { clockDivider: d.getUint8(0xd6) });\n    }\n    return undefined;\n}\n/** @hidden */\nfunction toVersionObject(code) {\n    var result = {\n        code: code,\n        major: (code >> 8).toString(16),\n        minor: (\"0\" + (code & 0xff).toString(16)).slice(-2)\n    };\n    return result;\n}\n/** @hidden */\nfunction parseNullTerminatedTextBlock(d, offset) {\n    var index = offset;\n    var pos = offset;\n    var result = [];\n    while (index < d.byteLength) {\n        var ch = d.getUint16(index);\n        if (ch === 0) {\n            var slice = new TextDecoder(\"utf-16\").decode(new Uint8Array(d.buffer, pos + d.byteOffset, index - pos));\n            result.push(slice);\n            index += 2;\n            pos = index;\n        }\n        else {\n            index += 2;\n        }\n    }\n    return result;\n}\n/** @hidden */\nfunction parseExtraHeader(data) {\n    var d = new DataView(data);\n    var size = d.getUint32(0x00, true);\n    var offsets = {};\n    var clocks;\n    var volumes;\n    if (8 <= size) {\n        offsets.chipClock = d.getUint32(0x04, true);\n        if (0 < offsets.chipClock) {\n            clocks = [];\n            var base = 0x04 + offsets.chipClock;\n            var count = d.getUint8(base);\n            for (var i = 0; i < count; i++) {\n                var chipId = d.getUint8(base + 1 + i * 5);\n                var clock = d.getUint32(base + 2 + i * 5, true);\n                var chip = vgm_object_1.chipIdToName(chipId) || \"unknown\";\n                clocks.push({ chip: chip, chipId: chipId, clock: clock });\n            }\n        }\n    }\n    if (12 <= size) {\n        offsets.chipVolume = d.getUint32(0x08, true);\n        if (0 < offsets.chipVolume) {\n            volumes = [];\n            var base = 0x08 + offsets.chipVolume;\n            var count = d.getUint8(base);\n            for (var i = 0; i < count; i++) {\n                var rawChipId = d.getUint8(base + 1 + i * 4);\n                var chipId = rawChipId & 0x7f;\n                var paired = rawChipId & 0x80 ? true : false;\n                var flags = d.getUint8(base + 2 + i * 4);\n                var rawVolume = d.getUint16(base + 3 + i * 4, true);\n                var volume = rawVolume & 0x7fff;\n                var absolute = rawVolume & 0x8000 ? true : false;\n                var chip = vgm_object_1.chipIdToName(chipId) || \"unknown\";\n                volumes.push({ chip: chip, chipId: chipId, paired: paired, flags: flags, volume: volume, absolute: absolute });\n            }\n        }\n    }\n    return {\n        clocks: clocks,\n        volumes: volumes\n    };\n}\n/** @hidden */\nfunction parseGD3(data) {\n    console.log(data.byteLength);\n    var d = new DataView(data);\n    var header = d.getUint32(0x00, true);\n    if (header != 0x20336447) {\n        return vgm_object_1.createEmptyGD3TagObject();\n    }\n    var version = d.getUint32(0x04, true);\n    var size = d.getUint32(0x08, true);\n    var texts = parseNullTerminatedTextBlock(d, 12);\n    return {\n        version: version,\n        size: size,\n        trackTitle: texts[0],\n        gameName: texts[2],\n        system: texts[4],\n        composer: texts[6],\n        releaseDate: texts[8],\n        vgmBy: texts[9],\n        notes: texts[10],\n        japanese: {\n            trackTitle: texts[1],\n            gameName: texts[3],\n            system: texts[5],\n            composer: texts[7]\n        }\n    };\n}\nfunction ensureGunzipped(data) {\n    var ua = new Uint8Array(data);\n    if (ua[0] === 0x1f && ua[1] === 0x8b) {\n        var unzip = new Zlib.Gunzip(ua);\n        var plain = unzip.decompress();\n        console.log(plain);\n        if (0 < plain.byteOffset) {\n            return plain.buffer.slice(plain.byteOffset);\n        }\n        return plain.buffer;\n    }\n    return data;\n}\nfunction parseVGM(input) {\n    var data = ensureGunzipped(input);\n    var d = new DataView(data);\n    var version = d.getUint32(0x08, true);\n    var chips = {\n        sn76489: getParamsSn76489(d),\n        ym2413: getParamsCommon(d, 0x10)\n    };\n    var eof = d.getUint32(0x04, true);\n    var gd3 = d.getUint32(0x14, true);\n    var loop = d.getUint32(0x1c, true);\n    var vgm = {\n        version: toVersionObject(version),\n        offsets: {\n            eof: eof ? 0x04 + eof : 0,\n            gd3: gd3 ? 0x14 + gd3 : 0,\n            loop: loop ? 0x1c + loop : 0,\n            data: 0x40,\n            extraHeader: 0\n        },\n        samples: {\n            total: d.getUint32(0x18, true),\n            loop: d.getUint32(0x20, true)\n        },\n        rate: d.getUint32(0x24, true),\n        chips: chips,\n        loopModifier: 0,\n        loopBase: 0,\n        volumeModifier: 0\n    };\n    if (version >= 0x110) {\n        chips.ym2612 = getParamsYm2612(d);\n        chips.ym2151 = getParamsYm2151(d);\n    }\n    if (version >= 0x150) {\n        vgm.offsets.data = 0x34 + d.getUint32(0x34, true);\n    }\n    if (version >= 0x151) {\n        chips.segaPcm = getParamsSegaPcm(d);\n        chips.rf5c68 = getParamsCommon(d, 0x40);\n        chips.ym2203 = getParamsYm2203(d);\n        chips.ym2608 = getParamsYm2608(d);\n        chips.ym2610 = getParamsYm2610(d);\n        chips.ym3812 = getParamsCommon(d, 0x50);\n        chips.ym3526 = getParamsCommon(d, 0x54);\n        chips.y8950 = getParamsCommon(d, 0x58);\n        chips.ymf262 = getParamsCommon(d, 0x5c);\n        chips.ymf278b = getParamsCommon(d, 0x60);\n        chips.ymf271 = getParamsCommon(d, 0x64);\n        chips.ymz280b = getParamsCommon(d, 0x68);\n        chips.rf5c164 = getParamsCommon(d, 0x6c);\n        chips.pwm = getParamsCommon(d, 0x70);\n        chips.ay8910 = getParamsAy8910(d);\n        vgm.loopModifier = d.getUint8(0x7f);\n    }\n    if (version >= 0x160) {\n        vgm.volumeModifier = d.getUint8(0x7c);\n        vgm.loopBase = d.getUint8(0x7e);\n    }\n    if (version >= 0x161) {\n        chips.gameBoyDmg = getParamsCommon(d, 0x80);\n        chips.nesApu = getParamsNesApu(d);\n        chips.multiPcm = getParamsCommon(d, 0x88);\n        chips.upd7759 = getParamsCommon(d, 0x8c);\n        chips.okim6258 = getParamsCommonWithFlags(d, 0x90, 0x94);\n        chips.c140 = getParamsC140(d);\n        chips.okim6295 = getParamsCommon(d, 0x98);\n        chips.k051649 = getParamsCommon(d, 0x9c);\n        chips.k054539 = getParamsCommonWithFlags(d, 0xa0, 0x95);\n        chips.huc6280 = getParamsCommon(d, 0xa4);\n        chips.k053260 = getParamsCommon(d, 0xac);\n        chips.pokey = getParamsCommon(d, 0xb0);\n        chips.qsound = getParamsCommon(d, 0xb4);\n    }\n    if (version >= 0x170) {\n        var v = d.getUint32(0xbc, true);\n        vgm.offsets.extraHeader = v ? 0xbc + v : 0;\n    }\n    if (version >= 0x171) {\n        chips.scsp = getParamsCommon(d, 0xb8);\n        chips.wonderSwan = getParamsCommon(d, 0xc0);\n        chips.vsu = getParamsCommon(d, 0xc4);\n        chips.saa1099 = getParamsCommon(d, 0xc8);\n        chips.es5506 = getParamsEs5506(d);\n        chips.es5503 = getParamsEs5503(d);\n        chips.x1_010 = getParamsCommon(d, 0xd8);\n        chips.c352 = getParamsC352(d);\n        chips.ga20 = getParamsCommon(d, 0xe0);\n    }\n    for (var key in chips) {\n        if (chips[key] == null) {\n            delete chips[key];\n        }\n    }\n    var extraHeader = vgm.offsets.extraHeader ? parseExtraHeader(data.slice(vgm.offsets.extraHeader)) : undefined;\n    var gd3tag = vgm.offsets.gd3 ? parseGD3(data.slice(vgm.offsets.gd3)) : undefined;\n    return __assign({}, vgm, { extraHeader: extraHeader, data: data.slice(vgm.offsets.data), gd3tag: gd3tag });\n}\nexports.parseVGM = parseVGM;\n\n\n//# sourceURL=webpack://VGM/./dist/parser.js?");

/***/ }),

/***/ "./dist/vgm.js":
/*!*********************!*\
  !*** ./dist/vgm.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar vgm_object_1 = __webpack_require__(/*! ./vgm_object */ \"./dist/vgm_object.js\");\nvar parser_1 = __webpack_require__(/*! ./parser */ \"./dist/parser.js\");\nvar builder_1 = __webpack_require__(/*! ./builder */ \"./dist/builder.js\");\nvar vgm_command_1 = __webpack_require__(/*! ./vgm_command */ \"./dist/vgm_command.js\");\nvar VGM = /** @class */ (function () {\n    function VGM(arg) {\n        if (arg) {\n            this._obj = vgm_object_1.deepCloneVGMObject(arg);\n        }\n        else {\n            this._obj = vgm_object_1.createEmptyVGMObject();\n        }\n    }\n    VGM.prototype._updateEOFOffset = function () {\n        if (this._obj.gd3tag) {\n            this._obj.offsets.gd3 = this._obj.offsets.data + this._obj.data.byteLength;\n            this._obj.offsets.eof = this._obj.offsets.gd3 + 12 + vgm_object_1.calcGD3TagBodySize(this._obj.gd3tag);\n        }\n        else {\n            this._obj.offsets.gd3 = 0;\n            this._obj.offsets.eof = this._obj.offsets.data + this._obj.data.byteLength;\n        }\n    };\n    Object.defineProperty(VGM.prototype, \"version\", {\n        get: function () {\n            return this._obj.version;\n        },\n        set: function (value) {\n            this._obj.version = __assign({}, value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(VGM.prototype, \"offsets\", {\n        get: function () {\n            return this._obj.offsets;\n        },\n        set: function (value) {\n            this._obj.offsets = __assign({}, value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(VGM.prototype, \"samples\", {\n        get: function () {\n            return this._obj.samples;\n        },\n        set: function (value) {\n            this._obj.samples = __assign({}, value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(VGM.prototype, \"rate\", {\n        get: function () {\n            return this._obj.rate;\n        },\n        set: function (value) {\n            this._obj.rate = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(VGM.prototype, \"chips\", {\n        get: function () {\n            return this._obj.chips;\n        },\n        set: function (value) {\n            this._obj.chips = vgm_object_1.deepCloneChipsObject(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(VGM.prototype, \"loopModifier\", {\n        get: function () {\n            return this._obj.loopModifier;\n        },\n        set: function (value) {\n            this._obj.loopModifier = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(VGM.prototype, \"loopBase\", {\n        get: function () {\n            return this._obj.loopBase;\n        },\n        set: function (value) {\n            this._obj.loopBase = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(VGM.prototype, \"volumeModifier\", {\n        get: function () {\n            return this._obj.volumeModifier;\n        },\n        set: function (value) {\n            this._obj.volumeModifier = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(VGM.prototype, \"data\", {\n        get: function () {\n            return this._obj.data;\n        },\n        /** this directly replace data buffer. To keep consistency, use setDataStream() or setData() instead. */\n        set: function (value) {\n            this._obj.data = value.slice(0);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(VGM.prototype, \"usedChips\", {\n        get: function () {\n            return Object.keys(this._obj.chips);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(VGM.prototype, \"gd3tag\", {\n        get: function () {\n            return this._obj.gd3tag;\n        },\n        set: function (value) {\n            this._obj.gd3tag = vgm_object_1.deepCloneGD3TagObject(value);\n            this._updateEOFOffset();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(VGM.prototype, \"extraHeader\", {\n        get: function () {\n            return this._obj.extraHeader;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Convert VGM instance to pure [[VGMObject]]. */\n    VGM.prototype.toObject = function () {\n        return vgm_object_1.deepCloneVGMObject(this._obj);\n    };\n    /** deep clone this instance. */\n    VGM.prototype.clone = function () {\n        return new VGM(vgm_object_1.deepCloneVGMObject(this._obj));\n    };\n    /**\n     * parse VGM binary and return VGM instance.\n     * @param data ArrayBuffer which contains VGM binary.\n     */\n    VGM.parse = function (data) {\n        return new VGM(parser_1.parseVGM(data));\n    };\n    VGM.prototype.build = function () {\n        return builder_1.buildVGM(this);\n    };\n    /**\n     * Access VGM data stream as a list of VGM commands.\n     * Note: This method always parses internal VGM data buffer.\n     */\n    VGM.prototype.getDataStream = function () {\n        return vgm_command_1.VGMDataStream.parse(this._obj);\n    };\n    /**\n     * set VGM data by VGMDataStream object\n     */\n    VGM.prototype.setDataStream = function (stream) {\n        this.setData(stream.build(), stream.totalSamples, stream.loopSamples, stream.loopByteOffset);\n    };\n    /**\n     * set VGM data with ArrayBuffer\n     * @param data ArrayBuffer which contains VGM data stream binary\n     * @param totalSamples Total samples\n     * @param loopSamples Loop samples. 0 if no loop\n     * @param loopByteOffset  Loop offset in byte. Relative from top of [data].\n     */\n    VGM.prototype.setData = function (data, totalSamples, loopSamples, loopByteOffset) {\n        this._obj.data = data.slice(0);\n        this._obj.offsets.loop = 0 < loopSamples ? this._obj.offsets.data + loopByteOffset : 0;\n        this._obj.samples = {\n            total: totalSamples,\n            loop: loopSamples\n        };\n        this._updateEOFOffset();\n    };\n    VGM.prototype.toJSON = function () {\n        return __assign({}, this._obj, { data: this.getDataStream() });\n    };\n    return VGM;\n}());\nexports.VGM = VGM;\n/**\n * convert samples to time, minute-seconds representation.\n * @param samples number of samples\n * @param sampleRate base sample rate\n */\nfunction formatMinSec(samples, sampleRate) {\n    if (sampleRate === void 0) { sampleRate = 44100; }\n    var millis = Math.round((samples / sampleRate) * 1000);\n    var minutes = Math.floor(millis / 60000);\n    var seconds = Math.floor((millis - minutes * 60000) / 1000);\n    var decimillis = Math.round((millis - seconds * 1000) / 10);\n    return (\"0\" + minutes).slice(-2) + \":\" + (\"0\" + seconds).slice(-2) + \".\" + (\"0\" + decimillis).slice(-2);\n}\nexports.formatMinSec = formatMinSec;\n\n\n//# sourceURL=webpack://VGM/./dist/vgm.js?");

/***/ }),

/***/ "./dist/vgm_command.js":
/*!*****************************!*\
  !*** ./dist/vgm_command.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar builder_1 = __webpack_require__(/*! ./builder */ \"./dist/builder.js\");\nfunction blockTypeToChipName(blockType) {\n    switch (blockType) {\n        case 0x00:\n        case 0x40:\n            return \"ym2612\";\n        case 0x01:\n        case 0x41:\n            return \"rf5c68\";\n        case 0x02:\n        case 0x42:\n            return \"rf5c164\";\n        case 0x03:\n        case 0x43:\n            return \"pwm\";\n        case 0x04:\n        case 0x44:\n            return \"okim6258\";\n        case 0x05:\n        case 0x45:\n            return \"huc6280\";\n        case 0x06:\n        case 0x46:\n            return \"scsp\";\n        case 0x07:\n        case 0x47:\n            return \"nesApu\";\n        case 0x80:\n            return \"segaPcm\";\n        case 0x81:\n            return \"ym2608\";\n        case 0x82:\n            return \"ym2610\";\n        case 0x83:\n            return \"ym2610\";\n        case 0x84:\n            return \"ymf278b\";\n        case 0x85:\n            return \"ymf271\";\n        case 0x86:\n            return \"ymz280b\";\n        case 0x87:\n            return \"ymf278b\";\n        case 0x88:\n            return \"y8950\";\n        case 0x89:\n            return \"multiPcm\";\n        case 0x8a:\n            return \"upd7759\";\n        case 0x8b:\n            return \"okim6295\";\n        case 0x8c:\n            return \"k054539\";\n        case 0x8d:\n            return \"c140\";\n        case 0x8e:\n            return \"k053260\";\n        case 0x8f:\n            return \"qsound\";\n        case 0x90:\n            return \"es5506\";\n        case 0x91:\n            return \"x1_010\";\n        case 0x92:\n            return \"c352\";\n        case 0x93:\n            return \"ga20\";\n        case 0xc0:\n            return \"rf5c68\";\n        case 0xc1:\n            return \"rf5c164\";\n        case 0xc2:\n            return \"nesApu\";\n        case 0xe0:\n            return \"scsp\";\n        case 0xe1:\n            return \"es5503\";\n        default:\n            return \"unknown\";\n    }\n}\nexports.blockTypeToChipName = blockTypeToChipName;\nfunction commandToChipName(cmd) {\n    switch (cmd) {\n        case 0x30:\n        case 0x50:\n            return \"sn76489\";\n        case 0x3f:\n        case 0x4f:\n            return \"gameGearStereo\";\n        case 0x51:\n        case 0xa1:\n            return \"ym2413\";\n        case 0x52:\n        case 0x53:\n        case 0xa2:\n        case 0xa3:\n            return \"ym2612\";\n        case 0x54:\n        case 0xa4:\n            return \"ym2151\";\n        case 0x55:\n        case 0xa5:\n            return \"ym2203\";\n        case 0x56:\n        case 0x57:\n        case 0xa6:\n        case 0xa7:\n            return \"ym2608\";\n        case 0x58:\n        case 0x59:\n        case 0xa8:\n        case 0xa9:\n            return \"ym2610\";\n        case 0x5a:\n        case 0xaa:\n            return \"ym3812\";\n        case 0x5b:\n        case 0xab:\n            return \"ym3526\";\n        case 0x5c:\n        case 0xac:\n            return \"y8950\";\n        case 0x5d:\n        case 0xad:\n            return \"ymz280b\";\n        case 0x5e:\n        case 0x5f:\n        case 0xae:\n        case 0xaf:\n            return \"ymf262\";\n        case 0xa0:\n            return \"ay8910\";\n        case 0xb0:\n            return \"rf5c68\";\n        case 0xb1:\n            return \"rf5c164\";\n        case 0xb2:\n            return \"pwm\";\n        case 0xb3:\n            return \"gameBoyDmg\";\n        case 0xb4:\n            return \"nesApu\";\n        case 0xb5:\n            return \"multiPcm\";\n        case 0xb6:\n            return \"upd7759\";\n        case 0xb7:\n            return \"okim6258\";\n        case 0xb8:\n            return \"okim6295\";\n        case 0xb9:\n            return \"huc6280\";\n        case 0xba:\n            return \"k053260\";\n        case 0xbb:\n            return \"pokey\";\n        case 0xbc:\n            return \"wonderSwan\";\n        case 0xbd:\n            return \"saa1099\";\n        case 0xbe:\n            return \"es5506\";\n        case 0xbf:\n            return \"ga20\";\n        case 0xc0:\n            return \"segaPcm\";\n        case 0xc1:\n            return \"rf5c68\";\n        case 0xc2:\n            return \"rf5c164\";\n        case 0xc3:\n            return \"multiPcm\";\n        case 0xc4:\n            return \"qsound\";\n        case 0xc5:\n            return \"scsp\";\n        case 0xc6:\n            return \"wonderSwan\";\n        case 0xc7:\n            return \"vsu\";\n        case 0xc8:\n            return \"x1_010\";\n        case 0xd0:\n            return \"ymf278b\";\n        case 0xd1:\n            return \"ymf271\";\n        case 0xd2:\n            return \"k051649\";\n        case 0xd3:\n            return \"k054539\";\n        case 0xd4:\n            return \"c140\";\n        case 0xd5:\n            return \"es5503\";\n        case 0xd6:\n            return \"es5506\";\n        case 0xe1:\n            return \"c352\";\n        default:\n            throw new Error(\"Unknown chip\");\n    }\n}\nexports.commandToChipName = commandToChipName;\nfunction getUint16BE(buf, pos) {\n    return ((buf[pos] & 0xff) << 8) | (buf[pos + 1] & 0xff);\n}\nfunction setUint16BE(buf, pos, data) {\n    buf[pos] = (data >> 8) & 0xff;\n    buf[pos + 1] = data & 0xff;\n}\nfunction getUint16LE(buf, pos) {\n    return (buf[pos] & 0xff) | ((buf[pos + 1] & 0xff) << 8);\n}\nfunction setUint16LE(buf, pos, data) {\n    buf[pos] = data & 0xff;\n    buf[pos + 1] = (data >> 8) & 0xff;\n}\nfunction getUint24LE(buf, pos) {\n    return (buf[pos] & 0xff) | ((buf[pos + 1] & 0xff) << 8) | ((buf[pos + 2] & 0xff) << 16);\n}\nfunction setUint24LE(buf, pos, data) {\n    buf[pos] = data & 0xff;\n    buf[pos + 1] = (data >> 8) & 0xff;\n    buf[pos + 2] = (data >> 16) & 0xff;\n}\nfunction getUint32LE(buf, pos) {\n    return ((buf[pos] & 0xff) | ((buf[pos + 1] & 0xff) << 8) | ((buf[pos + 2] & 0xff) << 16) | ((buf[pos + 3] & 0xff) << 24));\n}\nfunction setUint32LE(buf, pos, data) {\n    buf[pos] = data & 0xff;\n    buf[pos + 1] = (data >> 8) & 0xff;\n    buf[pos + 2] = (data >> 16) & 0xff;\n    buf[pos + 3] = (data >> 24) & 0xff;\n}\nvar VGMCommand = /** @class */ (function () {\n    function VGMCommand(cmd) {\n        this.cmd = cmd;\n    }\n    VGMCommand.prototype.toJSON = function () {\n        return this.toObject();\n    };\n    return VGMCommand;\n}());\nexports.VGMCommand = VGMCommand;\nvar VGMDataBlockCommand = /** @class */ (function (_super) {\n    __extends(VGMDataBlockCommand, _super);\n    function VGMDataBlockCommand(arg) {\n        var _this = _super.call(this, 0x67) || this;\n        _this.blockType = arg.blockType;\n        _this.blockSize = arg.blockSize;\n        _this.blockData = arg.blockData;\n        return _this;\n    }\n    VGMDataBlockCommand.prototype.copy = function (arg) {\n        return new VGMDataBlockCommand({\n            blockType: arg.blockType != null ? arg.blockType : this.blockType,\n            blockSize: arg.blockSize != null ? arg.blockSize : this.blockSize,\n            blockData: arg.blockData != null ? arg.blockData.slice(0) : this.blockData.slice(0)\n        });\n    };\n    VGMDataBlockCommand.prototype.clone = function () {\n        return this.copy({});\n    };\n    Object.defineProperty(VGMDataBlockCommand.prototype, \"chip\", {\n        get: function () {\n            return blockTypeToChipName(this.blockType);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(VGMDataBlockCommand.prototype, \"size\", {\n        get: function () {\n            return 7 + this.blockData.length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    VGMDataBlockCommand.prototype.toUint8Array = function () {\n        var res = new Uint8Array(this.size);\n        res[0] = 0x67;\n        res[1] = 0x66;\n        res[2] = this.blockType;\n        setUint32LE(res, 3, this.blockSize);\n        for (var i = 0; i < this.blockData.length; i++) {\n            res[i + 7] = this.blockData[i];\n        }\n        return res;\n    };\n    VGMDataBlockCommand.parse = function (buf, offset) {\n        if (buf[offset] === 0x67) {\n            var blockType = buf[offset + 2];\n            var blockSize = getUint32LE(buf, offset + 3);\n            var blockData = new Uint8Array(blockSize);\n            for (var i = 0; i < blockSize; i++) {\n                blockData[i] = buf[offset + 7 + i];\n            }\n            return new VGMDataBlockCommand({ blockType: blockType, blockSize: blockSize, blockData: blockData });\n        }\n        return null;\n    };\n    VGMDataBlockCommand.prototype.toObject = function () {\n        return {\n            cmd: this.cmd,\n            chip: this.chip,\n            size: this.size,\n            blockType: this.blockType,\n            blockSize: this.blockSize,\n            blockData: this.blockData.slice(0)\n        };\n    };\n    VGMDataBlockCommand.fromObject = function (obj) {\n        if (obj.cmd === 0x67) {\n            if (obj.blockType != null && obj.blockData != null && obj.blockSize != null) {\n                return new VGMDataBlockCommand(obj);\n            }\n            else {\n                throw new Error(\"Can't create VGMDataBlockCommand: required parameter is missing.\");\n            }\n        }\n        return null;\n    };\n    return VGMDataBlockCommand;\n}(VGMCommand));\nexports.VGMDataBlockCommand = VGMDataBlockCommand;\nvar VGMEndCommand = /** @class */ (function (_super) {\n    __extends(VGMEndCommand, _super);\n    function VGMEndCommand() {\n        return _super.call(this, 0x66) || this;\n    }\n    VGMEndCommand.prototype.copy = function (arg) {\n        return new VGMEndCommand();\n    };\n    VGMEndCommand.prototype.clone = function () {\n        return this.copy({});\n    };\n    Object.defineProperty(VGMEndCommand.prototype, \"size\", {\n        get: function () {\n            return 1;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    VGMEndCommand.prototype.toUint8Array = function () {\n        var res = new Uint8Array(1);\n        res[0] = 0x66;\n        return res;\n    };\n    VGMEndCommand.parse = function (buf, offset) {\n        if (offset === void 0) { offset = 0; }\n        if (buf[offset] === 0x66) {\n            return new VGMEndCommand();\n        }\n        return null;\n    };\n    VGMEndCommand.prototype.toObject = function () {\n        return {\n            cmd: this.cmd,\n            size: this.size\n        };\n    };\n    VGMEndCommand.fromObject = function (obj) {\n        if (obj.cmd === 0x66) {\n            return new VGMEndCommand();\n        }\n        return null;\n    };\n    return VGMEndCommand;\n}(VGMCommand));\nexports.VGMEndCommand = VGMEndCommand;\nvar VGMWaitCommand = /** @class */ (function (_super) {\n    __extends(VGMWaitCommand, _super);\n    function VGMWaitCommand(cmd, count) {\n        var _this = _super.call(this, cmd) || this;\n        if (cmd == 0x61) {\n            _this.count = count;\n        }\n        else if (cmd == 0x62) {\n            _this.count = 735;\n        }\n        else if (cmd == 0x63) {\n            _this.count = 882;\n        }\n        else if (0x70 <= cmd && cmd <= 0x7f) {\n            _this.count = (cmd & 15) + 1;\n        }\n        else {\n            throw new Error(\"0x\" + cmd.toString(16) + \" is not a VGMWaitCommand.\");\n        }\n        if (_this.count !== count) {\n            throw new Error(\"Count \" + count + \" is given for command 0x\" + cmd.toString(16) + \" but the count should be \" + _this.count + \".\");\n        }\n        return _this;\n    }\n    Object.defineProperty(VGMWaitCommand.prototype, \"size\", {\n        get: function () {\n            return this.cmd === 0x61 ? 3 : 1;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    VGMWaitCommand.prototype.toUint8Array = function () {\n        var res = new Uint8Array(this.size);\n        res[0] = this.cmd;\n        if (this.cmd === 0x61) {\n            setUint16LE(res, 1, this.count);\n        }\n        return res;\n    };\n    VGMWaitCommand.prototype.toObject = function () {\n        return {\n            cmd: this.cmd,\n            size: this.size,\n            count: this.count\n        };\n    };\n    return VGMWaitCommand;\n}(VGMCommand));\nexports.VGMWaitCommand = VGMWaitCommand;\nvar VGMWaitWordCommand = /** @class */ (function (_super) {\n    __extends(VGMWaitWordCommand, _super);\n    function VGMWaitWordCommand(arg) {\n        var _this = _super.call(this, 0x61, arg.count) || this;\n        if (arg.count < 0 || 65535 < arg.count) {\n            throw new Error(\"Count overflow: \" + arg.count);\n        }\n        return _this;\n    }\n    VGMWaitWordCommand.prototype.copy = function (arg) {\n        return new VGMWaitWordCommand({ count: arg.count != null ? arg.count : this.count });\n    };\n    VGMWaitWordCommand.prototype.clone = function () {\n        return this.copy({});\n    };\n    VGMWaitWordCommand.parse = function (buf, offset) {\n        if (offset === void 0) { offset = 0; }\n        var cmd = buf[offset];\n        if (cmd === 0x61) {\n            var nnnn = getUint16LE(buf, offset + 1);\n            return new VGMWaitWordCommand({ count: nnnn });\n        }\n        return null;\n    };\n    VGMWaitWordCommand.fromObject = function (obj) {\n        if (obj.cmd === 0x61) {\n            if (obj.count == null) {\n                throw new Error(\"Can't create VGMWaitCommand: obj.count is missing.\");\n            }\n            return new VGMWaitWordCommand({ count: obj.count });\n        }\n        return null;\n    };\n    return VGMWaitWordCommand;\n}(VGMWaitCommand));\nexports.VGMWaitWordCommand = VGMWaitWordCommand;\nvar VGMWaitNibbleCommand = /** @class */ (function (_super) {\n    __extends(VGMWaitNibbleCommand, _super);\n    function VGMWaitNibbleCommand(arg) {\n        var _this = _super.call(this, 0x70 | ((arg.count - 1) & 15), arg.count) || this;\n        if (arg.count < 1 || 16 < arg.count) {\n            throw new Error(\"Invalid count: \" + arg.count);\n        }\n        return _this;\n    }\n    VGMWaitNibbleCommand.prototype.copy = function (arg) {\n        return new VGMWaitNibbleCommand({ count: arg.count != null ? arg.count : this.count });\n    };\n    VGMWaitNibbleCommand.prototype.clone = function () {\n        return this.copy({});\n    };\n    VGMWaitNibbleCommand.parse = function (buf, offset) {\n        if (offset === void 0) { offset = 0; }\n        var cmd = buf[offset];\n        if (0x70 <= cmd && cmd <= 0x7f) {\n            return new VGMWaitNibbleCommand({ count: (cmd & 15) + 1 });\n        }\n        return null;\n    };\n    VGMWaitNibbleCommand.fromObject = function (obj) {\n        if (0x70 <= obj.cmd && obj.cmd <= 0x7f) {\n            return new VGMWaitNibbleCommand({ count: (obj.cmd & 15) + 1 });\n        }\n        return null;\n    };\n    return VGMWaitNibbleCommand;\n}(VGMWaitCommand));\nexports.VGMWaitNibbleCommand = VGMWaitNibbleCommand;\nvar VGMWait735Command = /** @class */ (function (_super) {\n    __extends(VGMWait735Command, _super);\n    function VGMWait735Command() {\n        return _super.call(this, 0x62, 735) || this;\n    }\n    VGMWait735Command.prototype.copy = function (arg) {\n        return new VGMWait735Command();\n    };\n    VGMWait735Command.prototype.clone = function () {\n        return this.copy({});\n    };\n    VGMWait735Command.parse = function (buf, offset) {\n        if (offset === void 0) { offset = 0; }\n        var cmd = buf[offset];\n        if (cmd === 0x62) {\n            return new VGMWait735Command();\n        }\n        return null;\n    };\n    VGMWait735Command.fromObject = function (obj) {\n        if (obj.cmd === 0x62) {\n            return new VGMWait735Command();\n        }\n        return null;\n    };\n    return VGMWait735Command;\n}(VGMWaitCommand));\nexports.VGMWait735Command = VGMWait735Command;\nvar VGMWait882Command = /** @class */ (function (_super) {\n    __extends(VGMWait882Command, _super);\n    function VGMWait882Command() {\n        return _super.call(this, 0x63, 882) || this;\n    }\n    VGMWait882Command.prototype.copy = function (arg) {\n        return new VGMWait882Command();\n    };\n    VGMWait882Command.prototype.clone = function () {\n        return this.copy({});\n    };\n    VGMWait882Command.parse = function (buf, offset) {\n        if (offset === void 0) { offset = 0; }\n        var cmd = buf[offset];\n        if (cmd === 0x63) {\n            return new VGMWait882Command();\n        }\n        return null;\n    };\n    VGMWait882Command.fromObject = function (obj) {\n        if (obj.cmd === 0x63) {\n            return new VGMWait882Command();\n        }\n        return null;\n    };\n    return VGMWait882Command;\n}(VGMWaitCommand));\nexports.VGMWait882Command = VGMWait882Command;\nvar VGMWrite2ACommand = /** @class */ (function (_super) {\n    __extends(VGMWrite2ACommand, _super);\n    function VGMWrite2ACommand(arg) {\n        var _this = _super.call(this, 0x80 | (arg.count & 15)) || this;\n        if (arg.count < 0 || 15 < arg.count) {\n            throw new Error(\"Invalid count \" + arg.count + \" for VGMWrite2ACommand.\");\n        }\n        return _this;\n    }\n    VGMWrite2ACommand.prototype.copy = function (arg) {\n        return new VGMWrite2ACommand({ count: arg.count != null ? arg.count : this.count });\n    };\n    VGMWrite2ACommand.prototype.clone = function () {\n        return this.copy({});\n    };\n    Object.defineProperty(VGMWrite2ACommand.prototype, \"count\", {\n        get: function () {\n            return this.cmd & 0xf;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(VGMWrite2ACommand.prototype, \"size\", {\n        get: function () {\n            return 1;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    VGMWrite2ACommand.prototype.toUint8Array = function () {\n        var res = new Uint8Array(this.size);\n        res[0] = this.cmd;\n        return res;\n    };\n    VGMWrite2ACommand.parse = function (buf, offset) {\n        if (offset === void 0) { offset = 0; }\n        var cmd = buf[offset];\n        if (0x80 <= cmd && cmd <= 0x8f) {\n            return new VGMWrite2ACommand({ count: cmd & 15 });\n        }\n        return null;\n    };\n    VGMWrite2ACommand.prototype.toObject = function () {\n        return {\n            cmd: this.cmd,\n            size: this.size,\n            count: this.count\n        };\n    };\n    VGMWrite2ACommand.fromObject = function (obj) {\n        if (0x80 <= obj.cmd && obj.cmd <= 0x8f) {\n            return new VGMWrite2ACommand({ count: obj.cmd & 15 });\n        }\n        return null;\n    };\n    return VGMWrite2ACommand;\n}(VGMCommand));\nexports.VGMWrite2ACommand = VGMWrite2ACommand;\nvar VGMPCMRAMWriteCommand = /** @class */ (function (_super) {\n    __extends(VGMPCMRAMWriteCommand, _super);\n    function VGMPCMRAMWriteCommand(arg) {\n        var _this = _super.call(this, 0x68) || this;\n        _this.blockType = arg.blockType;\n        _this.readOffset = arg.readOffset;\n        _this.writeOffset = arg.writeOffset;\n        _this.writeSize = arg.writeSize;\n        return _this;\n    }\n    VGMPCMRAMWriteCommand.prototype.copy = function (arg) {\n        return new VGMPCMRAMWriteCommand({\n            blockType: arg.blockType != null ? arg.blockType : this.blockType,\n            readOffset: arg.readOffset != null ? arg.readOffset : this.readOffset,\n            writeOffset: arg.writeOffset != null ? arg.writeOffset : this.writeOffset,\n            writeSize: arg.writeSize != null ? arg.writeSize : this.writeSize\n        });\n    };\n    VGMPCMRAMWriteCommand.prototype.clone = function () {\n        return this.copy({});\n    };\n    Object.defineProperty(VGMPCMRAMWriteCommand.prototype, \"size\", {\n        get: function () {\n            return 12;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    VGMPCMRAMWriteCommand.prototype.toUint8Array = function () {\n        var res = new Uint8Array(this.size);\n        res[0] = this.cmd;\n        res[1] = 0x66;\n        res[2] = this.blockType;\n        setUint24LE(res, 3, this.readOffset);\n        setUint24LE(res, 6, this.writeOffset);\n        setUint24LE(res, 9, this.writeSize);\n        return res;\n    };\n    VGMPCMRAMWriteCommand.parse = function (buf, offset) {\n        if (offset === void 0) { offset = 0; }\n        var cmd = buf[offset];\n        if (cmd === 0x68) {\n            var blockType = buf[offset + 2];\n            var readOffset = getUint24LE(buf, offset + 3);\n            var writeOffset = getUint24LE(buf, offset + 6);\n            var writeSize = getUint24LE(buf, offset + 9);\n            return new VGMPCMRAMWriteCommand({ blockType: blockType, readOffset: readOffset, writeOffset: writeOffset, writeSize: writeSize });\n        }\n        return null;\n    };\n    VGMPCMRAMWriteCommand.prototype.toObject = function () {\n        return {\n            cmd: this.cmd,\n            size: this.size,\n            blockType: this.blockType,\n            readOffset: this.readOffset,\n            writeOffset: this.writeOffset,\n            writeSize: this.writeSize\n        };\n    };\n    VGMPCMRAMWriteCommand.fromObject = function (obj) {\n        if (obj.cmd === 0x68) {\n            if (obj.blockType == null || obj.readOffset == null || obj.writeOffset == null || obj.writeSize == null) {\n                throw new Error(\"Can't create VGMPCMRAMWriteCommand: required parameter is missing.\");\n            }\n            return new VGMPCMRAMWriteCommand(obj);\n        }\n        return null;\n    };\n    return VGMPCMRAMWriteCommand;\n}(VGMCommand));\nexports.VGMPCMRAMWriteCommand = VGMPCMRAMWriteCommand;\nvar VGMWriteDataCommand = /** @class */ (function (_super) {\n    __extends(VGMWriteDataCommand, _super);\n    function VGMWriteDataCommand(arg) {\n        var _this = _super.call(this, arg.cmd) || this;\n        _this.chip = commandToChipName(arg.cmd);\n        _this.index = arg.index || 0;\n        _this.port = arg.port || 0;\n        _this.addr = arg.addr || 0;\n        _this.data = arg.data;\n        if ((0x30 <= _this.cmd && _this.cmd <= 0x3f) || _this.cmd === 0x4f || _this.cmd === 0x50) {\n            _this.size = 2;\n        }\n        else if (0x40 <= _this.cmd && _this.cmd <= 0x4e) {\n            _this.size = 3;\n        }\n        else if (0x51 <= _this.cmd && _this.cmd <= 0x5f) {\n            _this.size = 3;\n        }\n        else if (0xa0 <= _this.cmd && _this.cmd <= 0xbf) {\n            _this.size = 3;\n        }\n        else if (0xc0 <= _this.cmd && _this.cmd <= 0xdf) {\n            _this.size = 4;\n        }\n        else if (0xe0 <= _this.cmd && _this.cmd <= 0xff) {\n            _this.size = 5;\n        }\n        else {\n            throw new Error(_this.cmd + \" is not a VGMWriteDataComand.\");\n        }\n        return _this;\n    }\n    VGMWriteDataCommand.prototype.copy = function (arg) {\n        return new VGMWriteDataCommand({\n            cmd: arg.cmd != null ? arg.cmd : this.cmd,\n            index: arg.index != null ? arg.index : this.index,\n            port: arg.port != null ? arg.port : this.port,\n            addr: arg.addr != null ? arg.addr : this.addr,\n            data: arg.data != null ? arg.data : this.data\n        });\n    };\n    VGMWriteDataCommand.prototype.clone = function () {\n        return this.copy({});\n    };\n    VGMWriteDataCommand.prototype.toUint8Array = function () {\n        var res = new Uint8Array(this.size);\n        res[0] = this.cmd;\n        if ((0x30 <= this.cmd && this.cmd <= 0x3f) || this.cmd === 0x4f || this.cmd === 0x50) {\n            res[1] = this.data;\n            return res;\n        }\n        else if ((0x51 <= this.cmd && this.cmd <= 0x5f) || (0xa0 <= this.cmd && this.cmd <= 0xbf)) {\n            res[1] = this.addr;\n            res[2] = this.data;\n            return res;\n        }\n        else if (0xc0 <= this.cmd && this.cmd <= 0xc2) {\n            setUint16LE(res, 1, this.addr | this.index ? 0x8000 : 0);\n            res[3] = this.data;\n            return res;\n        }\n        else if (0xc3 === this.cmd) {\n            res[1] = this.addr | this.index ? 0x80 : 0;\n            setUint16LE(res, 2, this.data);\n            return res;\n        }\n        else if (0xc4 === this.cmd) {\n            setUint16BE(res, 1, this.data);\n            res[3] = this.addr;\n            return res;\n        }\n        else if (0xc5 <= this.cmd && this.cmd <= 0xc8) {\n            setUint16BE(res, 1, this.addr | this.index ? 0x8000 : 0);\n            res[3] = this.data;\n            return res;\n        }\n        else if (0xd0 <= this.cmd && this.cmd <= 0xd2) {\n            res[1] = this.port | this.index ? 0x80 : 0;\n            res[2] = this.addr;\n            res[3] = this.data;\n            return res;\n        }\n        else if (0xd3 <= this.cmd && this.cmd <= 0xd5) {\n            setUint16BE(res, 1, this.addr | this.index ? 0x8000 : 0);\n            res[3] = this.data;\n            return res;\n        }\n        else if (0xd6 === this.cmd) {\n            res[1] = this.addr | this.index ? 0x80 : 0;\n            setUint16BE(res, 2, this.data);\n            return res;\n        }\n        else if (0xe1 === this.cmd) {\n            setUint16BE(res, 1, this.addr | this.index ? 0x8000 : 0);\n            setUint16BE(res, 3, this.data);\n            return res;\n        }\n        else {\n            throw new Error(this.cmd + \" is not a VGMWriteDataCommand\");\n        }\n    };\n    Object.defineProperty(VGMWriteDataCommand.prototype, \"chipName\", {\n        get: function () {\n            return commandToChipName(this.cmd);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    VGMWriteDataCommand.parse = function (buf, offset) {\n        if (offset === void 0) { offset = 0; }\n        var cmd = buf[offset + 0];\n        if (0x30 <= cmd && cmd <= 0x3f) {\n            // 0x30: 2nd SN76489, 0x31-0x3e: Reserved, 0x3f: 2nd GG Sterao\n            return new VGMWriteDataCommand({ cmd: cmd, index: 1, data: buf[offset + 1] });\n        }\n        else if (cmd === 0x4f) {\n            // 1st GG Stereo\n            return new VGMWriteDataCommand({ cmd: cmd, index: 0, data: buf[offset + 1] });\n        }\n        else if (cmd === 0x50) {\n            // 1st SN76489\n            return new VGMWriteDataCommand({ cmd: cmd, index: 0, data: buf[offset + 1] });\n        }\n        else if (cmd === 0xa0) {\n            // AY-3-8910\n            var addr = buf[offset + 1];\n            var index = addr & 0x80 ? 1 : 0;\n            return new VGMWriteDataCommand({ cmd: cmd, index: index, port: 0, addr: addr & 0x7f, data: buf[offset + 2] });\n        }\n        else if ((0x51 <= cmd && cmd <= 0x5f) || (0xa1 <= cmd && cmd <= 0xaf)) {\n            var index = (cmd & 0xf0) === 0x50 ? 0 : 1;\n            var port = 0 <= [0x3, 0x7, 0x9, 0xf].indexOf(cmd & 0x0f) ? 1 : 0;\n            return new VGMWriteDataCommand({ cmd: cmd, index: index, port: port, addr: buf[offset + 1], data: buf[offset + 2] });\n        }\n        else if (0xb0 <= cmd && cmd <= 0xbf) {\n            var addr = buf[offset + 1];\n            var index = addr & 0x80 ? 1 : 0;\n            return new VGMWriteDataCommand({ cmd: cmd, index: index, addr: addr & 0x7f, data: buf[offset + 2] });\n        }\n        else if (0xc0 <= cmd && cmd <= 0xc2) {\n            var addr = getUint16LE(buf, offset + 1);\n            var index = addr & 0x8000 ? 1 : 0;\n            return new VGMWriteDataCommand({ cmd: cmd, index: index, addr: addr & 0x7fff, data: buf[offset + 3] });\n        }\n        else if (0xc3 === cmd) {\n            var addr = buf[offset + 1];\n            var index = addr & 0x80 ? 1 : 0;\n            return new VGMWriteDataCommand({ cmd: cmd, index: index, addr: addr & 0x7f, data: getUint16LE(buf, offset + 2) });\n        }\n        else if (0xc4 === cmd) {\n            return new VGMWriteDataCommand({ cmd: cmd, index: 0, addr: buf[3], data: getUint16BE(buf, offset + 1) });\n        }\n        else if (0xc5 <= cmd && cmd <= 0xc8) {\n            var addr = getUint16BE(buf, offset + 1);\n            var index = addr & 0x8000 ? 1 : 0;\n            return new VGMWriteDataCommand({ cmd: cmd, index: index, addr: addr & 0x7fff, data: buf[offset + 3] });\n        }\n        else if (0xd0 <= cmd && cmd <= 0xd2) {\n            var port = buf[offset + 1] & 0x7f;\n            var index = buf[offset + 1] & 0x80 ? 1 : 0;\n            return new VGMWriteDataCommand({ cmd: cmd, index: index, port: port, addr: buf[offset + 2], data: buf[offset + 3] });\n        }\n        else if (0xd3 <= cmd && cmd <= 0xd5) {\n            var addr = getUint16BE(buf, offset + 1);\n            var index = addr & 0x8000 ? 1 : 0;\n            return new VGMWriteDataCommand({ cmd: cmd, index: index, addr: addr & 0x7fff, data: buf[offset + 3] });\n        }\n        else if (cmd === 0xd6) {\n            var addr = buf[offset + 1];\n            var index = addr & 0x80 ? 1 : 0;\n            return new VGMWriteDataCommand({ cmd: cmd, index: index, addr: addr & 0x7f, data: getUint16BE(buf, offset + 3) });\n        }\n        else if (cmd === 0xe1) {\n            var addr = getUint16BE(buf, offset + 1);\n            var index = addr & 0x8000 ? 1 : 0;\n            return new VGMWriteDataCommand({ cmd: cmd, index: index, addr: addr & 0x7fff, data: getUint16BE(buf, offset + 3) });\n        }\n        return null;\n    };\n    VGMWriteDataCommand.prototype.toObject = function () {\n        return {\n            cmd: this.cmd,\n            chip: this.chip,\n            size: this.size,\n            index: this.index,\n            port: this.port,\n            addr: this.addr,\n            data: this.data\n        };\n    };\n    VGMWriteDataCommand.fromObject = function (obj) {\n        var cmd = obj.cmd;\n        if (cmd === 0x30 ||\n            cmd === 0x3f ||\n            cmd === 0x4f ||\n            (0x50 <= cmd && cmd <= 0x5f) ||\n            (0xa0 <= cmd && cmd <= 0xdf) ||\n            cmd === 0xe0 ||\n            cmd === 0xe1) {\n            return new VGMWriteDataCommand(obj);\n        }\n        return null;\n    };\n    return VGMWriteDataCommand;\n}(VGMCommand));\nexports.VGMWriteDataCommand = VGMWriteDataCommand;\nvar VGMStreamCommand = /** @class */ (function (_super) {\n    __extends(VGMStreamCommand, _super);\n    function VGMStreamCommand(cmd, streamId) {\n        var _this = _super.call(this, cmd) || this;\n        _this.streamId = streamId;\n        return _this;\n    }\n    return VGMStreamCommand;\n}(VGMCommand));\nexports.VGMStreamCommand = VGMStreamCommand;\nvar VGMSetupStreamCommand = /** @class */ (function (_super) {\n    __extends(VGMSetupStreamCommand, _super);\n    function VGMSetupStreamCommand(arg) {\n        var _this = _super.call(this, 0x90, arg.streamId) || this;\n        _this.type = arg.type;\n        _this.port = arg.port;\n        _this.channel = arg.channel;\n        return _this;\n    }\n    VGMSetupStreamCommand.prototype.copy = function (arg) {\n        return new VGMSetupStreamCommand({\n            streamId: arg.streamId != null ? arg.streamId : this.streamId,\n            type: arg.type != null ? arg.type : this.type,\n            port: arg.port != null ? arg.port : this.port,\n            channel: arg.channel != null ? arg.channel : this.channel\n        });\n    };\n    VGMSetupStreamCommand.prototype.clone = function () {\n        return this.copy({});\n    };\n    Object.defineProperty(VGMSetupStreamCommand.prototype, \"size\", {\n        get: function () {\n            return 5;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    VGMSetupStreamCommand.prototype.toUint8Array = function () {\n        var res = new Uint8Array(this.size);\n        res[0] = 0x90;\n        res[1] = this.streamId;\n        res[2] = this.type;\n        res[3] = this.port;\n        res[4] = this.channel;\n        return res;\n    };\n    VGMSetupStreamCommand.parse = function (buf, offset) {\n        if (offset === void 0) { offset = 0; }\n        var cmd = buf[offset];\n        if (cmd === 0x90) {\n            return new VGMSetupStreamCommand({\n                streamId: buf[offset + 1],\n                type: buf[offset + 2],\n                port: buf[offset + 3],\n                channel: buf[offset + 4]\n            });\n        }\n        return null;\n    };\n    VGMSetupStreamCommand.prototype.toObject = function () {\n        return {\n            cmd: this.cmd,\n            size: this.size,\n            streamId: this.streamId,\n            type: this.type,\n            port: this.port,\n            channel: this.channel\n        };\n    };\n    VGMSetupStreamCommand.fromObject = function (obj) {\n        var cmd = obj.cmd;\n        if (cmd === 0x90) {\n            if (obj.streamId == null || obj.type == null || obj.port == null || obj.channel == null) {\n                throw new Error(\"Can't create VGMSetupStreamCommand: required parameter is missing.\");\n            }\n            return new VGMSetupStreamCommand(obj);\n        }\n        return null;\n    };\n    return VGMSetupStreamCommand;\n}(VGMStreamCommand));\nexports.VGMSetupStreamCommand = VGMSetupStreamCommand;\nvar VGMSetStreamDataCommand = /** @class */ (function (_super) {\n    __extends(VGMSetStreamDataCommand, _super);\n    function VGMSetStreamDataCommand(arg) {\n        var _this = _super.call(this, 0x91, arg.streamId) || this;\n        _this.dataBankId = arg.dataBankId;\n        _this.stepSize = arg.stepSize;\n        _this.stepBase = arg.stepBase;\n        return _this;\n    }\n    VGMSetStreamDataCommand.prototype.copy = function (arg) {\n        return new VGMSetStreamDataCommand({\n            streamId: arg.streamId != null ? arg.streamId : this.streamId,\n            dataBankId: arg.dataBankId != null ? arg.dataBankId : this.dataBankId,\n            stepSize: arg.stepSize != null ? arg.stepSize : this.stepSize,\n            stepBase: arg.stepBase != null ? arg.stepBase : this.stepBase\n        });\n    };\n    VGMSetStreamDataCommand.prototype.clone = function () {\n        return this.copy({});\n    };\n    Object.defineProperty(VGMSetStreamDataCommand.prototype, \"size\", {\n        get: function () {\n            return 5;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    VGMSetStreamDataCommand.prototype.toUint8Array = function () {\n        var res = new Uint8Array(this.size);\n        res[0] = 0x91;\n        res[1] = this.streamId;\n        res[2] = this.dataBankId;\n        res[3] = this.stepSize;\n        res[4] = this.stepBase;\n        return res;\n    };\n    VGMSetStreamDataCommand.parse = function (buf, offset) {\n        if (offset === void 0) { offset = 0; }\n        var cmd = buf[offset];\n        if (cmd === 0x91) {\n            return new VGMSetStreamDataCommand({\n                streamId: buf[offset + 1],\n                dataBankId: buf[offset + 2],\n                stepSize: buf[offset + 3],\n                stepBase: buf[offset + 4]\n            });\n        }\n        return null;\n    };\n    VGMSetStreamDataCommand.prototype.toObject = function () {\n        return {\n            cmd: this.cmd,\n            size: this.size,\n            streamId: this.streamId,\n            dataBankId: this.dataBankId,\n            stepBase: this.stepBase,\n            stepSize: this.stepSize\n        };\n    };\n    VGMSetStreamDataCommand.fromObject = function (obj) {\n        var cmd = obj.cmd;\n        if (cmd === 0x91) {\n            if (obj.streamId == null || obj.dataBankId == null || obj.stepBase == null || obj.stepSize == null) {\n                throw new Error(\"Can't create VGMSetStreamDataCommand: required parameter is missing.\");\n            }\n            return new VGMSetStreamDataCommand(obj);\n        }\n        return null;\n    };\n    return VGMSetStreamDataCommand;\n}(VGMStreamCommand));\nexports.VGMSetStreamDataCommand = VGMSetStreamDataCommand;\nvar VGMSetStreamFrequencyCommand = /** @class */ (function (_super) {\n    __extends(VGMSetStreamFrequencyCommand, _super);\n    function VGMSetStreamFrequencyCommand(arg) {\n        var _this = _super.call(this, 0x92, arg.streamId) || this;\n        _this.frequency = arg.frequency;\n        return _this;\n    }\n    VGMSetStreamFrequencyCommand.prototype.copy = function (arg) {\n        return new VGMSetStreamFrequencyCommand({\n            streamId: arg.streamId != null ? arg.streamId : this.streamId,\n            frequency: arg.frequency != null ? arg.frequency : this.frequency\n        });\n    };\n    VGMSetStreamFrequencyCommand.prototype.clone = function () {\n        return this.copy({});\n    };\n    Object.defineProperty(VGMSetStreamFrequencyCommand.prototype, \"size\", {\n        get: function () {\n            return 6;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    VGMSetStreamFrequencyCommand.prototype.toUint8Array = function () {\n        var res = new Uint8Array(this.size);\n        res[0] = 0x92;\n        res[1] = this.streamId;\n        setUint32LE(res, 2, this.frequency);\n        return res;\n    };\n    VGMSetStreamFrequencyCommand.parse = function (buf, offset) {\n        if (offset === void 0) { offset = 0; }\n        var cmd = buf[offset];\n        if (cmd === 0x92) {\n            return new VGMSetStreamFrequencyCommand({\n                streamId: buf[offset + 1],\n                frequency: getUint32LE(buf, offset + 2)\n            });\n        }\n        return null;\n    };\n    VGMSetStreamFrequencyCommand.prototype.toObject = function () {\n        return {\n            cmd: this.cmd,\n            size: this.size,\n            streamId: this.streamId,\n            frequency: this.frequency\n        };\n    };\n    VGMSetStreamFrequencyCommand.fromObject = function (obj) {\n        var cmd = obj.cmd;\n        if (cmd === 0x92) {\n            if (obj.streamId == null || obj.frequency == null) {\n                throw new Error(\"Can't create VGMSetStreamFrequencyCommand: required parameter is missing.\");\n            }\n            return new VGMSetStreamFrequencyCommand(obj);\n        }\n        return null;\n    };\n    return VGMSetStreamFrequencyCommand;\n}(VGMStreamCommand));\nexports.VGMSetStreamFrequencyCommand = VGMSetStreamFrequencyCommand;\nvar VGMStartStreamCommand = /** @class */ (function (_super) {\n    __extends(VGMStartStreamCommand, _super);\n    function VGMStartStreamCommand(arg) {\n        var _this = _super.call(this, 0x93, arg.streamId) || this;\n        _this.offset = arg.offset;\n        _this.lengthMode = arg.lengthMode;\n        _this.dataLength = arg.dataLength;\n        return _this;\n    }\n    VGMStartStreamCommand.prototype.copy = function (arg) {\n        return new VGMStartStreamCommand({\n            streamId: arg.streamId != null ? arg.streamId : this.streamId,\n            offset: arg.offset != null ? arg.offset : this.offset,\n            lengthMode: arg.lengthMode != null ? arg.lengthMode : this.lengthMode,\n            dataLength: arg.dataLength != null ? arg.dataLength : this.dataLength\n        });\n    };\n    VGMStartStreamCommand.prototype.clone = function () {\n        return this.copy({});\n    };\n    Object.defineProperty(VGMStartStreamCommand.prototype, \"size\", {\n        get: function () {\n            return 11;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    VGMStartStreamCommand.prototype.toUint8Array = function () {\n        var res = new Uint8Array(this.size);\n        res[0] = 0x93;\n        res[1] = this.streamId;\n        setUint32LE(res, 2, this.offset);\n        res[6] = this.lengthMode;\n        setUint32LE(res, 7, this.dataLength);\n        return res;\n    };\n    VGMStartStreamCommand.parse = function (buf, offset) {\n        if (offset === void 0) { offset = 0; }\n        var cmd = buf[offset];\n        if (cmd === 0x93) {\n            return new VGMStartStreamCommand({\n                streamId: buf[offset + 1],\n                offset: getUint32LE(buf, offset + 2),\n                lengthMode: buf[offset + 6],\n                dataLength: getUint32LE(buf, offset + 7)\n            });\n        }\n        return null;\n    };\n    VGMStartStreamCommand.prototype.toObject = function () {\n        return {\n            cmd: this.cmd,\n            size: this.size,\n            streamId: this.streamId,\n            offset: this.offset,\n            lengthMode: this.lengthMode,\n            dataLength: this.dataLength\n        };\n    };\n    VGMStartStreamCommand.fromObject = function (obj) {\n        var cmd = obj.cmd;\n        if (cmd === 0x93) {\n            if (obj.streamId == null || obj.offset == null || obj.lengthMode == null || obj.dataLength == null) {\n                throw new Error(\"Can't create VGMStartStreamCommand: required parameter is missing.\");\n            }\n            return new VGMStartStreamCommand(obj);\n        }\n        return null;\n    };\n    return VGMStartStreamCommand;\n}(VGMStreamCommand));\nexports.VGMStartStreamCommand = VGMStartStreamCommand;\nvar VGMStopStreamCommand = /** @class */ (function (_super) {\n    __extends(VGMStopStreamCommand, _super);\n    function VGMStopStreamCommand(arg) {\n        return _super.call(this, 0x94, arg.streamId) || this;\n    }\n    VGMStopStreamCommand.prototype.copy = function (arg) {\n        return new VGMStopStreamCommand({\n            streamId: arg.streamId != null ? arg.streamId : this.streamId\n        });\n    };\n    VGMStopStreamCommand.prototype.clone = function () {\n        return this.copy({});\n    };\n    Object.defineProperty(VGMStopStreamCommand.prototype, \"size\", {\n        get: function () {\n            return 2;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    VGMStopStreamCommand.prototype.toUint8Array = function () {\n        var res = new Uint8Array(this.size);\n        res[0] = 0x94;\n        res[1] = this.streamId;\n        return res;\n    };\n    VGMStopStreamCommand.parse = function (buf, offset) {\n        if (offset === void 0) { offset = 0; }\n        var cmd = buf[offset];\n        if (cmd === 0x94) {\n            return new VGMStopStreamCommand({ streamId: buf[offset + 1] });\n        }\n        return null;\n    };\n    VGMStopStreamCommand.prototype.toObject = function () {\n        return {\n            cmd: this.cmd,\n            size: this.size,\n            streamId: this.streamId\n        };\n    };\n    VGMStopStreamCommand.fromObject = function (obj) {\n        var cmd = obj.cmd;\n        if (cmd === 0x91) {\n            if (obj.streamId == null) {\n                throw new Error(\"Can't create VGMStopStreamCommand: required parameter is missing.\");\n            }\n            return new VGMStopStreamCommand(obj);\n        }\n        return null;\n    };\n    return VGMStopStreamCommand;\n}(VGMStreamCommand));\nexports.VGMStopStreamCommand = VGMStopStreamCommand;\nvar VGMStartStreamFastCommand = /** @class */ (function (_super) {\n    __extends(VGMStartStreamFastCommand, _super);\n    function VGMStartStreamFastCommand(arg) {\n        var _this = _super.call(this, 0x95, arg.streamId) || this;\n        _this.blockId = arg.blockId;\n        _this.flags = arg.flags;\n        return _this;\n    }\n    VGMStartStreamFastCommand.prototype.copy = function (arg) {\n        return new VGMStartStreamFastCommand({\n            streamId: arg.streamId != null ? arg.streamId : this.streamId,\n            blockId: arg.blockId != null ? arg.blockId : this.blockId,\n            flags: arg.flags != null ? arg.flags : this.flags\n        });\n    };\n    VGMStartStreamFastCommand.prototype.clone = function () {\n        return this.copy({});\n    };\n    Object.defineProperty(VGMStartStreamFastCommand.prototype, \"size\", {\n        get: function () {\n            return 5;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    VGMStartStreamFastCommand.prototype.toUint8Array = function () {\n        var res = new Uint8Array(this.size);\n        res[0] = 0x95;\n        res[1] = this.streamId;\n        setUint16LE(res, 2, this.blockId);\n        res[4] = this.flags;\n        return res;\n    };\n    VGMStartStreamFastCommand.parse = function (buf, offset) {\n        if (offset === void 0) { offset = 0; }\n        var cmd = buf[offset];\n        if (cmd === 0x95) {\n            return new VGMStartStreamFastCommand({\n                streamId: buf[offset + 1],\n                blockId: getUint16LE(buf, offset + 2),\n                flags: buf[offset + 4]\n            });\n        }\n        return null;\n    };\n    VGMStartStreamFastCommand.prototype.toObject = function () {\n        return {\n            cmd: this.cmd,\n            size: this.size,\n            streamId: this.streamId,\n            blockId: this.blockId,\n            flags: this.flags\n        };\n    };\n    VGMStartStreamFastCommand.fromObject = function (obj) {\n        var cmd = obj.cmd;\n        if (cmd === 0x95) {\n            if (obj.streamId == null || obj.blockId == null || obj.flags == null) {\n                throw new Error(\"Can't create VGMStartStreamFastCommand: required parameter is missing.\");\n            }\n            return new VGMStartStreamFastCommand(obj);\n        }\n        return null;\n    };\n    return VGMStartStreamFastCommand;\n}(VGMStreamCommand));\nexports.VGMStartStreamFastCommand = VGMStartStreamFastCommand;\nvar VGMSeekPCMCommand = /** @class */ (function (_super) {\n    __extends(VGMSeekPCMCommand, _super);\n    function VGMSeekPCMCommand(arg) {\n        var _this = _super.call(this, 0xe0) || this;\n        _this.offset = arg.offset;\n        return _this;\n    }\n    VGMSeekPCMCommand.prototype.copy = function (arg) {\n        return new VGMSeekPCMCommand({ offset: arg.offset != null ? arg.offset : this.offset });\n    };\n    VGMSeekPCMCommand.prototype.clone = function () {\n        return this.copy({});\n    };\n    Object.defineProperty(VGMSeekPCMCommand.prototype, \"size\", {\n        get: function () {\n            return 5;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    VGMSeekPCMCommand.prototype.toUint8Array = function () {\n        var res = new Uint8Array(this.size);\n        res[0] = 0xe0;\n        setUint32LE(res, 1, this.offset);\n        return res;\n    };\n    VGMSeekPCMCommand.parse = function (buf, offset) {\n        if (offset === void 0) { offset = 0; }\n        var cmd = buf[offset];\n        if (cmd === 0xe0) {\n            return new VGMSeekPCMCommand({ offset: getUint32LE(buf, offset + 1) });\n        }\n        return null;\n    };\n    VGMSeekPCMCommand.prototype.toObject = function () {\n        return {\n            cmd: this.cmd,\n            size: this.size,\n            offset: this.offset\n        };\n    };\n    VGMSeekPCMCommand.fromObject = function (obj) {\n        var cmd = obj.cmd;\n        if (cmd === 0xe0) {\n            if (obj.offset == null) {\n                throw new Error(\"Can't create VGMSeekPCMCommand: required parameter is missing.\");\n            }\n            return new VGMSeekPCMCommand(obj);\n        }\n        return null;\n    };\n    return VGMSeekPCMCommand;\n}(VGMCommand));\nexports.VGMSeekPCMCommand = VGMSeekPCMCommand;\nfunction parseVGMCommand(buf, offset) {\n    var result = VGMWrite2ACommand.parse(buf, offset) ||\n        VGMWriteDataCommand.parse(buf, offset) ||\n        VGMWaitNibbleCommand.parse(buf, offset) ||\n        VGMWaitWordCommand.parse(buf, offset) ||\n        VGMWait735Command.parse(buf, offset) ||\n        VGMWait882Command.parse(buf, offset) ||\n        VGMSeekPCMCommand.parse(buf, offset) ||\n        VGMDataBlockCommand.parse(buf, offset) ||\n        VGMPCMRAMWriteCommand.parse(buf, offset) ||\n        VGMSetupStreamCommand.parse(buf, offset) ||\n        VGMSetStreamDataCommand.parse(buf, offset) ||\n        VGMSetStreamFrequencyCommand.parse(buf, offset) ||\n        VGMStartStreamCommand.parse(buf, offset) ||\n        VGMStopStreamCommand.parse(buf, offset) ||\n        VGMStartStreamFastCommand.parse(buf, offset) ||\n        VGMEndCommand.parse(buf, offset);\n    if (result) {\n        return result;\n    }\n    if (buf instanceof ArrayBuffer) {\n        throw new Error(\"Parse Error:: The buffer should not be an ArrayBuffer.\");\n    }\n    if (offset < buf.length) {\n        throw new Error(\"Parse Error:: 0x\" + buf[offset].toString(16));\n    }\n    throw new Error(\"Parse Error:: offset is out of range.\");\n}\nexports.parseVGMCommand = parseVGMCommand;\nfunction fromVGMCommandObject(obj) {\n    var result = VGMWrite2ACommand.fromObject(obj) ||\n        VGMWriteDataCommand.fromObject(obj) ||\n        VGMWaitNibbleCommand.fromObject(obj) ||\n        VGMWaitWordCommand.fromObject(obj) ||\n        VGMWait735Command.fromObject(obj) ||\n        VGMWait882Command.fromObject(obj) ||\n        VGMSeekPCMCommand.fromObject(obj) ||\n        VGMDataBlockCommand.fromObject(obj) ||\n        VGMPCMRAMWriteCommand.fromObject(obj) ||\n        VGMSetupStreamCommand.fromObject(obj) ||\n        VGMSetStreamDataCommand.fromObject(obj) ||\n        VGMSetStreamFrequencyCommand.fromObject(obj) ||\n        VGMStartStreamCommand.fromObject(obj) ||\n        VGMStopStreamCommand.fromObject(obj) ||\n        VGMStartStreamFastCommand.fromObject(obj) ||\n        VGMEndCommand.fromObject(obj);\n    if (result) {\n        return result;\n    }\n    throw new Error(\"Unsupported command: 0x\" + obj.cmd.toString(16));\n}\nexports.fromVGMCommandObject = fromVGMCommandObject;\nvar VGMDataStream = /** @class */ (function () {\n    function VGMDataStream(commands) {\n        if (commands === void 0) { commands = []; }\n        this.byteLength = 0;\n        this.totalSamples = 0;\n        this.loopSamples = 0;\n        this.loopIndexOffset = 0;\n        this.loopByteOffset = 0;\n        this._loop = false;\n        this.commands = commands;\n    }\n    VGMDataStream.prototype.clone = function () {\n        var res = new VGMDataStream(this.commands.map(function (e) { return e.clone(); }));\n        res.byteLength = this.byteLength;\n        res.totalSamples = this.totalSamples;\n        res.loopSamples = this.loopSamples;\n        res.loopIndexOffset = this.loopIndexOffset;\n        res.loopByteOffset = this.loopByteOffset;\n        return res;\n    };\n    VGMDataStream.prototype.clear = function () {\n        this.commands = [];\n        this.totalSamples = 0;\n        this.loopSamples = 0;\n        this.loopIndexOffset = 0;\n        this.byteLength = 0;\n        this.loopByteOffset = 0;\n        this._loop = false;\n    };\n    Object.defineProperty(VGMDataStream.prototype, \"length\", {\n        get: function () {\n            return this.commands.length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    VGMDataStream.prototype.push = function (cmd) {\n        if (cmd instanceof VGMWaitCommand || cmd instanceof VGMWrite2ACommand) {\n            this.totalSamples += cmd.count;\n            if (this._loop) {\n                this.loopSamples += cmd.count;\n            }\n        }\n        this.commands.push(cmd);\n        this.byteLength += cmd.size;\n    };\n    VGMDataStream.prototype.markLoopPoint = function () {\n        this._loop = true;\n        this.loopIndexOffset = this.commands.length;\n        this.loopByteOffset = this.byteLength;\n        this.loopSamples = 0;\n    };\n    VGMDataStream.parse = function (vgm) {\n        var data = new Uint8Array(vgm.data);\n        var res = new VGMDataStream();\n        var rp = 0;\n        while (rp < data.byteLength) {\n            if (vgm.offsets.data + rp === vgm.offsets.loop) {\n                res.markLoopPoint();\n            }\n            var cmd = parseVGMCommand(data, rp);\n            if (cmd == null)\n                break;\n            res.push(cmd);\n            rp += cmd.size;\n            if (cmd instanceof VGMEndCommand)\n                break;\n        }\n        return res;\n    };\n    VGMDataStream.prototype.build = function () {\n        return builder_1.buildVGMData(this.commands);\n    };\n    VGMDataStream.prototype.toJSON = function () {\n        var _a = this, commands = _a.commands, loopSamples = _a.loopSamples, loopIndexOffset = _a.loopIndexOffset, loopByteOffset = _a.loopByteOffset, totalSamples = _a.totalSamples, byteLength = _a.byteLength;\n        return {\n            byteLength: byteLength,\n            loopSamples: loopSamples,\n            totalSamples: totalSamples,\n            loopIndexOffset: loopIndexOffset,\n            loopByteOffset: loopByteOffset,\n            commands: commands\n        };\n    };\n    return VGMDataStream;\n}());\nexports.VGMDataStream = VGMDataStream;\n\n\n//# sourceURL=webpack://VGM/./dist/vgm_command.js?");

/***/ }),

/***/ "./dist/vgm_object.js":
/*!****************************!*\
  !*** ./dist/vgm_object.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// prettier-ignore\nvar _chipIdToName = [\n    \"sn76489\", \"ym2413\", \"ym2612\", \"ym2151\", \"segaPcm\", \"rf5c68\", \"ym2203\", \"ym2608\", \"ym2610\",\n    \"ym3812\", \"ym3526\", \"y8950\", \"ymf262\", \"ymf278b\", \"ymf271\", \"ymz280b\", \"rf5c164\",\n    \"pwm\", \"ay8910\", \"gameBoyDmg\", \"nesApu\", \"multiPcm\", \"upd7759\", \"okim6258\", \"okim6295\",\n    \"k051649\", \"k054539\", \"huc6280\", \"c140\", \"k053260\", \"pokey\", \"qsound\", \"scsp\", \"wonderSwan\",\n    \"vsu\", \"saa1099\", \"es5503\", \"es5506\", \"x1_010\", \"c352\", \"ga20\"\n];\nfunction chipIdToName(chipId) {\n    return _chipIdToName[chipId];\n}\nexports.chipIdToName = chipIdToName;\nfunction deepCloneChipsObject(chips) {\n    return JSON.parse(JSON.stringify(chips));\n}\nexports.deepCloneChipsObject = deepCloneChipsObject;\nfunction deepCloneExtraHeaderObject(arg) {\n    return arg ? JSON.parse(JSON.stringify(arg)) : undefined;\n}\nexports.deepCloneExtraHeaderObject = deepCloneExtraHeaderObject;\nfunction createEmptyGD3TagObject() {\n    return {\n        version: 0x100,\n        size: 22,\n        trackTitle: \"\",\n        gameName: \"\",\n        system: \"\",\n        composer: \"\",\n        releaseDate: \"\",\n        vgmBy: \"\",\n        notes: \"\",\n        japanese: {\n            trackTitle: \"\",\n            gameName: \"\",\n            system: \"\",\n            composer: \"\"\n        }\n    };\n}\nexports.createEmptyGD3TagObject = createEmptyGD3TagObject;\nfunction deepCloneGD3TagObject(arg) {\n    return arg ? __assign({}, arg, { japanese: __assign({}, arg.japanese) }) : undefined;\n}\nexports.deepCloneGD3TagObject = deepCloneGD3TagObject;\nfunction deepCloneVGMObject(arg) {\n    return {\n        version: __assign({}, arg.version),\n        offsets: __assign({}, arg.offsets),\n        samples: __assign({}, arg.samples),\n        rate: arg.rate,\n        chips: __assign({}, arg.chips),\n        loopModifier: arg.loopModifier,\n        loopBase: arg.loopBase,\n        volumeModifier: arg.volumeModifier,\n        extraHeader: deepCloneExtraHeaderObject(arg.extraHeader),\n        data: arg.data.slice(0),\n        gd3tag: deepCloneGD3TagObject(arg.gd3tag)\n    };\n}\nexports.deepCloneVGMObject = deepCloneVGMObject;\nfunction createEmptyVGMObject() {\n    return {\n        version: {\n            code: 0x170,\n            major: \"1\",\n            minor: \"70\"\n        },\n        offsets: {\n            eof: 0,\n            data: 0x100,\n            loop: 0,\n            gd3: 0,\n            extraHeader: 0\n        },\n        samples: {\n            loop: 0,\n            total: 0\n        },\n        chips: {},\n        rate: 60,\n        loopModifier: 0,\n        loopBase: 0,\n        volumeModifier: 0,\n        extraHeader: undefined,\n        data: new ArrayBuffer(0),\n        gd3tag: undefined\n    };\n}\nexports.createEmptyVGMObject = createEmptyVGMObject;\nfunction calcGD3TagBodySize(obj) {\n    return ((obj.trackTitle.length +\n        obj.gameName.length +\n        obj.system.length +\n        obj.composer.length +\n        obj.releaseDate.length +\n        obj.vgmBy.length +\n        obj.notes.length +\n        obj.japanese.trackTitle.length +\n        obj.japanese.gameName.length +\n        obj.japanese.system.length +\n        obj.japanese.composer.length +\n        11) *\n        2);\n}\nexports.calcGD3TagBodySize = calcGD3TagBodySize;\n\n\n//# sourceURL=webpack://VGM/./dist/vgm_object.js?");

/***/ }),

/***/ "./node_modules/node-libs-browser/node_modules/inherits/inherits_browser.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/node-libs-browser/node_modules/inherits/inherits_browser.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n//# sourceURL=webpack://VGM/./node_modules/node-libs-browser/node_modules/inherits/inherits_browser.js?");

/***/ }),

/***/ "./node_modules/node-libs-browser/node_modules/util/support/isBufferBrowser.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/node-libs-browser/node_modules/util/support/isBufferBrowser.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}\n\n//# sourceURL=webpack://VGM/./node_modules/node-libs-browser/node_modules/util/support/isBufferBrowser.js?");

/***/ }),

/***/ "./node_modules/node-libs-browser/node_modules/util/util.js":
/*!******************************************************************!*\
  !*** ./node_modules/node-libs-browser/node_modules/util/util.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||\n  function getOwnPropertyDescriptors(obj) {\n    var keys = Object.keys(obj);\n    var descriptors = {};\n    for (var i = 0; i < keys.length; i++) {\n      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);\n    }\n    return descriptors;\n  };\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  if (typeof process !== 'undefined' && process.noDeprecation === true) {\n    return fn;\n  }\n\n  // Allow for deprecating things in the process of starting up.\n  if (typeof process === 'undefined') {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ \"./node_modules/node-libs-browser/node_modules/util/support/isBufferBrowser.js\");\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = __webpack_require__(/*! inherits */ \"./node_modules/node-libs-browser/node_modules/inherits/inherits_browser.js\");\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nvar kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;\n\nexports.promisify = function promisify(original) {\n  if (typeof original !== 'function')\n    throw new TypeError('The \"original\" argument must be of type Function');\n\n  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {\n    var fn = original[kCustomPromisifiedSymbol];\n    if (typeof fn !== 'function') {\n      throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n    }\n    Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n      value: fn, enumerable: false, writable: false, configurable: true\n    });\n    return fn;\n  }\n\n  function fn() {\n    var promiseResolve, promiseReject;\n    var promise = new Promise(function (resolve, reject) {\n      promiseResolve = resolve;\n      promiseReject = reject;\n    });\n\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n    args.push(function (err, value) {\n      if (err) {\n        promiseReject(err);\n      } else {\n        promiseResolve(value);\n      }\n    });\n\n    try {\n      original.apply(this, args);\n    } catch (err) {\n      promiseReject(err);\n    }\n\n    return promise;\n  }\n\n  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));\n\n  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n    value: fn, enumerable: false, writable: false, configurable: true\n  });\n  return Object.defineProperties(\n    fn,\n    getOwnPropertyDescriptors(original)\n  );\n}\n\nexports.promisify.custom = kCustomPromisifiedSymbol\n\nfunction callbackifyOnRejected(reason, cb) {\n  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).\n  // Because `null` is a special error value in callbacks which means \"no error\n  // occurred\", we error-wrap so the callback consumer can distinguish between\n  // \"the promise rejected with null\" or \"the promise fulfilled with undefined\".\n  if (!reason) {\n    var newReason = new Error('Promise was rejected with a falsy value');\n    newReason.reason = reason;\n    reason = newReason;\n  }\n  return cb(reason);\n}\n\nfunction callbackify(original) {\n  if (typeof original !== 'function') {\n    throw new TypeError('The \"original\" argument must be of type Function');\n  }\n\n  // We DO NOT return the promise as it gives the user a false sense that\n  // the promise is actually somehow related to the callback's execution\n  // and that the callback throwing will reject the promise.\n  function callbackified() {\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n\n    var maybeCb = args.pop();\n    if (typeof maybeCb !== 'function') {\n      throw new TypeError('The last argument must be of type Function');\n    }\n    var self = this;\n    var cb = function() {\n      return maybeCb.apply(self, arguments);\n    };\n    // In true node style we process the callback on `nextTick` with all the\n    // implications (stack, `uncaughtException`, `async_hooks`)\n    original.apply(this, args)\n      .then(function(ret) { process.nextTick(cb, null, ret) },\n            function(rej) { process.nextTick(callbackifyOnRejected, rej, cb) });\n  }\n\n  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));\n  Object.defineProperties(callbackified,\n                          getOwnPropertyDescriptors(original));\n  return callbackified;\n}\nexports.callbackify = callbackify;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack://VGM/./node_modules/node-libs-browser/node_modules/util/util.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack://VGM/./node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/zlibjs/bin/gunzip.min.js":
/*!***********************************************!*\
  !*** ./node_modules/zlibjs/bin/gunzip.min.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/** @license zlib.js 2012 - imaya [ https://github.com/imaya/zlib.js ] The MIT License */(function() {'use strict';function n(e){throw e;}var p=void 0,aa=this;function t(e,b){var d=e.split(\".\"),c=aa;!(d[0]in c)&&c.execScript&&c.execScript(\"var \"+d[0]);for(var a;d.length&&(a=d.shift());)!d.length&&b!==p?c[a]=b:c=c[a]?c[a]:c[a]={}};var x=\"undefined\"!==typeof Uint8Array&&\"undefined\"!==typeof Uint16Array&&\"undefined\"!==typeof Uint32Array&&\"undefined\"!==typeof DataView;new (x?Uint8Array:Array)(256);var y;for(y=0;256>y;++y)for(var A=y,ba=7,A=A>>>1;A;A>>>=1)--ba;function B(e,b,d){var c,a=\"number\"===typeof b?b:b=0,f=\"number\"===typeof d?d:e.length;c=-1;for(a=f&7;a--;++b)c=c>>>8^C[(c^e[b])&255];for(a=f>>3;a--;b+=8)c=c>>>8^C[(c^e[b])&255],c=c>>>8^C[(c^e[b+1])&255],c=c>>>8^C[(c^e[b+2])&255],c=c>>>8^C[(c^e[b+3])&255],c=c>>>8^C[(c^e[b+4])&255],c=c>>>8^C[(c^e[b+5])&255],c=c>>>8^C[(c^e[b+6])&255],c=c>>>8^C[(c^e[b+7])&255];return(c^4294967295)>>>0}\nvar D=[0,1996959894,3993919788,2567524794,124634137,1886057615,3915621685,2657392035,249268274,2044508324,3772115230,2547177864,162941995,2125561021,3887607047,2428444049,498536548,1789927666,4089016648,2227061214,450548861,1843258603,4107580753,2211677639,325883990,1684777152,4251122042,2321926636,335633487,1661365465,4195302755,2366115317,997073096,1281953886,3579855332,2724688242,1006888145,1258607687,3524101629,2768942443,901097722,1119000684,3686517206,2898065728,853044451,1172266101,3705015759,\n2882616665,651767980,1373503546,3369554304,3218104598,565507253,1454621731,3485111705,3099436303,671266974,1594198024,3322730930,2970347812,795835527,1483230225,3244367275,3060149565,1994146192,31158534,2563907772,4023717930,1907459465,112637215,2680153253,3904427059,2013776290,251722036,2517215374,3775830040,2137656763,141376813,2439277719,3865271297,1802195444,476864866,2238001368,4066508878,1812370925,453092731,2181625025,4111451223,1706088902,314042704,2344532202,4240017532,1658658271,366619977,\n2362670323,4224994405,1303535960,984961486,2747007092,3569037538,1256170817,1037604311,2765210733,3554079995,1131014506,879679996,2909243462,3663771856,1141124467,855842277,2852801631,3708648649,1342533948,654459306,3188396048,3373015174,1466479909,544179635,3110523913,3462522015,1591671054,702138776,2966460450,3352799412,1504918807,783551873,3082640443,3233442989,3988292384,2596254646,62317068,1957810842,3939845945,2647816111,81470997,1943803523,3814918930,2489596804,225274430,2053790376,3826175755,\n2466906013,167816743,2097651377,4027552580,2265490386,503444072,1762050814,4150417245,2154129355,426522225,1852507879,4275313526,2312317920,282753626,1742555852,4189708143,2394877945,397917763,1622183637,3604390888,2714866558,953729732,1340076626,3518719985,2797360999,1068828381,1219638859,3624741850,2936675148,906185462,1090812512,3747672003,2825379669,829329135,1181335161,3412177804,3160834842,628085408,1382605366,3423369109,3138078467,570562233,1426400815,3317316542,2998733608,733239954,1555261956,\n3268935591,3050360625,752459403,1541320221,2607071920,3965973030,1969922972,40735498,2617837225,3943577151,1913087877,83908371,2512341634,3803740692,2075208622,213261112,2463272603,3855990285,2094854071,198958881,2262029012,4057260610,1759359992,534414190,2176718541,4139329115,1873836001,414664567,2282248934,4279200368,1711684554,285281116,2405801727,4167216745,1634467795,376229701,2685067896,3608007406,1308918612,956543938,2808555105,3495958263,1231636301,1047427035,2932959818,3654703836,1088359270,\n936918E3,2847714899,3736837829,1202900863,817233897,3183342108,3401237130,1404277552,615818150,3134207493,3453421203,1423857449,601450431,3009837614,3294710456,1567103746,711928724,3020668471,3272380065,1510334235,755167117],C=x?new Uint32Array(D):D;function E(){}E.prototype.getName=function(){return this.name};E.prototype.getData=function(){return this.data};E.prototype.G=function(){return this.H};function G(e){var b=e.length,d=0,c=Number.POSITIVE_INFINITY,a,f,k,l,m,r,q,g,h,v;for(g=0;g<b;++g)e[g]>d&&(d=e[g]),e[g]<c&&(c=e[g]);a=1<<d;f=new (x?Uint32Array:Array)(a);k=1;l=0;for(m=2;k<=d;){for(g=0;g<b;++g)if(e[g]===k){r=0;q=l;for(h=0;h<k;++h)r=r<<1|q&1,q>>=1;v=k<<16|g;for(h=r;h<a;h+=m)f[h]=v;++l}++k;l<<=1;m<<=1}return[f,d,c]};var J=[],K;for(K=0;288>K;K++)switch(!0){case 143>=K:J.push([K+48,8]);break;case 255>=K:J.push([K-144+400,9]);break;case 279>=K:J.push([K-256+0,7]);break;case 287>=K:J.push([K-280+192,8]);break;default:n(\"invalid literal: \"+K)}\nvar ca=function(){function e(a){switch(!0){case 3===a:return[257,a-3,0];case 4===a:return[258,a-4,0];case 5===a:return[259,a-5,0];case 6===a:return[260,a-6,0];case 7===a:return[261,a-7,0];case 8===a:return[262,a-8,0];case 9===a:return[263,a-9,0];case 10===a:return[264,a-10,0];case 12>=a:return[265,a-11,1];case 14>=a:return[266,a-13,1];case 16>=a:return[267,a-15,1];case 18>=a:return[268,a-17,1];case 22>=a:return[269,a-19,2];case 26>=a:return[270,a-23,2];case 30>=a:return[271,a-27,2];case 34>=a:return[272,\na-31,2];case 42>=a:return[273,a-35,3];case 50>=a:return[274,a-43,3];case 58>=a:return[275,a-51,3];case 66>=a:return[276,a-59,3];case 82>=a:return[277,a-67,4];case 98>=a:return[278,a-83,4];case 114>=a:return[279,a-99,4];case 130>=a:return[280,a-115,4];case 162>=a:return[281,a-131,5];case 194>=a:return[282,a-163,5];case 226>=a:return[283,a-195,5];case 257>=a:return[284,a-227,5];case 258===a:return[285,a-258,0];default:n(\"invalid length: \"+a)}}var b=[],d,c;for(d=3;258>=d;d++)c=e(d),b[d]=c[2]<<24|c[1]<<\n16|c[0];return b}();x&&new Uint32Array(ca);function L(e,b){this.i=[];this.j=32768;this.d=this.f=this.c=this.n=0;this.input=x?new Uint8Array(e):e;this.o=!1;this.k=M;this.w=!1;if(b||!(b={}))b.index&&(this.c=b.index),b.bufferSize&&(this.j=b.bufferSize),b.bufferType&&(this.k=b.bufferType),b.resize&&(this.w=b.resize);switch(this.k){case N:this.a=32768;this.b=new (x?Uint8Array:Array)(32768+this.j+258);break;case M:this.a=0;this.b=new (x?Uint8Array:Array)(this.j);this.e=this.D;this.q=this.A;this.l=this.C;break;default:n(Error(\"invalid inflate mode\"))}}\nvar N=0,M=1;\nL.prototype.g=function(){for(;!this.o;){var e=P(this,3);e&1&&(this.o=!0);e>>>=1;switch(e){case 0:var b=this.input,d=this.c,c=this.b,a=this.a,f=b.length,k=p,l=p,m=c.length,r=p;this.d=this.f=0;d+1>=f&&n(Error(\"invalid uncompressed block header: LEN\"));k=b[d++]|b[d++]<<8;d+1>=f&&n(Error(\"invalid uncompressed block header: NLEN\"));l=b[d++]|b[d++]<<8;k===~l&&n(Error(\"invalid uncompressed block header: length verify\"));d+k>b.length&&n(Error(\"input buffer is broken\"));switch(this.k){case N:for(;a+k>c.length;){r=\nm-a;k-=r;if(x)c.set(b.subarray(d,d+r),a),a+=r,d+=r;else for(;r--;)c[a++]=b[d++];this.a=a;c=this.e();a=this.a}break;case M:for(;a+k>c.length;)c=this.e({t:2});break;default:n(Error(\"invalid inflate mode\"))}if(x)c.set(b.subarray(d,d+k),a),a+=k,d+=k;else for(;k--;)c[a++]=b[d++];this.c=d;this.a=a;this.b=c;break;case 1:this.l(da,ea);break;case 2:for(var q=P(this,5)+257,g=P(this,5)+1,h=P(this,4)+4,v=new (x?Uint8Array:Array)(Q.length),s=p,F=p,H=p,w=p,z=p,O=p,I=p,u=p,Z=p,u=0;u<h;++u)v[Q[u]]=P(this,3);if(!x){u=\nh;for(h=v.length;u<h;++u)v[Q[u]]=0}s=G(v);w=new (x?Uint8Array:Array)(q+g);u=0;for(Z=q+g;u<Z;)switch(z=R(this,s),z){case 16:for(I=3+P(this,2);I--;)w[u++]=O;break;case 17:for(I=3+P(this,3);I--;)w[u++]=0;O=0;break;case 18:for(I=11+P(this,7);I--;)w[u++]=0;O=0;break;default:O=w[u++]=z}F=x?G(w.subarray(0,q)):G(w.slice(0,q));H=x?G(w.subarray(q)):G(w.slice(q));this.l(F,H);break;default:n(Error(\"unknown BTYPE: \"+e))}}return this.q()};\nvar S=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],Q=x?new Uint16Array(S):S,fa=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,258,258],ga=x?new Uint16Array(fa):fa,ha=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0],T=x?new Uint8Array(ha):ha,ia=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],ja=x?new Uint16Array(ia):ia,ka=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,\n11,12,12,13,13],U=x?new Uint8Array(ka):ka,V=new (x?Uint8Array:Array)(288),W,la;W=0;for(la=V.length;W<la;++W)V[W]=143>=W?8:255>=W?9:279>=W?7:8;var da=G(V),X=new (x?Uint8Array:Array)(30),Y,ma;Y=0;for(ma=X.length;Y<ma;++Y)X[Y]=5;var ea=G(X);function P(e,b){for(var d=e.f,c=e.d,a=e.input,f=e.c,k=a.length,l;c<b;)f>=k&&n(Error(\"input buffer is broken\")),d|=a[f++]<<c,c+=8;l=d&(1<<b)-1;e.f=d>>>b;e.d=c-b;e.c=f;return l}\nfunction R(e,b){for(var d=e.f,c=e.d,a=e.input,f=e.c,k=a.length,l=b[0],m=b[1],r,q;c<m&&!(f>=k);)d|=a[f++]<<c,c+=8;r=l[d&(1<<m)-1];q=r>>>16;q>c&&n(Error(\"invalid code length: \"+q));e.f=d>>q;e.d=c-q;e.c=f;return r&65535}\nL.prototype.l=function(e,b){var d=this.b,c=this.a;this.r=e;for(var a=d.length-258,f,k,l,m;256!==(f=R(this,e));)if(256>f)c>=a&&(this.a=c,d=this.e(),c=this.a),d[c++]=f;else{k=f-257;m=ga[k];0<T[k]&&(m+=P(this,T[k]));f=R(this,b);l=ja[f];0<U[f]&&(l+=P(this,U[f]));c>=a&&(this.a=c,d=this.e(),c=this.a);for(;m--;)d[c]=d[c++-l]}for(;8<=this.d;)this.d-=8,this.c--;this.a=c};\nL.prototype.C=function(e,b){var d=this.b,c=this.a;this.r=e;for(var a=d.length,f,k,l,m;256!==(f=R(this,e));)if(256>f)c>=a&&(d=this.e(),a=d.length),d[c++]=f;else{k=f-257;m=ga[k];0<T[k]&&(m+=P(this,T[k]));f=R(this,b);l=ja[f];0<U[f]&&(l+=P(this,U[f]));c+m>a&&(d=this.e(),a=d.length);for(;m--;)d[c]=d[c++-l]}for(;8<=this.d;)this.d-=8,this.c--;this.a=c};\nL.prototype.e=function(){var e=new (x?Uint8Array:Array)(this.a-32768),b=this.a-32768,d,c,a=this.b;if(x)e.set(a.subarray(32768,e.length));else{d=0;for(c=e.length;d<c;++d)e[d]=a[d+32768]}this.i.push(e);this.n+=e.length;if(x)a.set(a.subarray(b,b+32768));else for(d=0;32768>d;++d)a[d]=a[b+d];this.a=32768;return a};\nL.prototype.D=function(e){var b,d=this.input.length/this.c+1|0,c,a,f,k=this.input,l=this.b;e&&(\"number\"===typeof e.t&&(d=e.t),\"number\"===typeof e.z&&(d+=e.z));2>d?(c=(k.length-this.c)/this.r[2],f=258*(c/2)|0,a=f<l.length?l.length+f:l.length<<1):a=l.length*d;x?(b=new Uint8Array(a),b.set(l)):b=l;return this.b=b};\nL.prototype.q=function(){var e=0,b=this.b,d=this.i,c,a=new (x?Uint8Array:Array)(this.n+(this.a-32768)),f,k,l,m;if(0===d.length)return x?this.b.subarray(32768,this.a):this.b.slice(32768,this.a);f=0;for(k=d.length;f<k;++f){c=d[f];l=0;for(m=c.length;l<m;++l)a[e++]=c[l]}f=32768;for(k=this.a;f<k;++f)a[e++]=b[f];this.i=[];return this.buffer=a};\nL.prototype.A=function(){var e,b=this.a;x?this.w?(e=new Uint8Array(b),e.set(this.b.subarray(0,b))):e=this.b.subarray(0,b):(this.b.length>b&&(this.b.length=b),e=this.b);return this.buffer=e};function $(e){this.input=e;this.c=0;this.m=[];this.s=!1}$.prototype.F=function(){this.s||this.g();return this.m.slice()};\n$.prototype.g=function(){for(var e=this.input.length;this.c<e;){var b=new E,d=p,c=p,a=p,f=p,k=p,l=p,m=p,r=p,q=p,g=this.input,h=this.c;b.u=g[h++];b.v=g[h++];(31!==b.u||139!==b.v)&&n(Error(\"invalid file signature:\"+b.u+\",\"+b.v));b.p=g[h++];switch(b.p){case 8:break;default:n(Error(\"unknown compression method: \"+b.p))}b.h=g[h++];r=g[h++]|g[h++]<<8|g[h++]<<16|g[h++]<<24;b.H=new Date(1E3*r);b.N=g[h++];b.M=g[h++];0<(b.h&4)&&(b.I=g[h++]|g[h++]<<8,h+=b.I);if(0<(b.h&8)){m=[];for(l=0;0<(k=g[h++]);)m[l++]=String.fromCharCode(k);\nb.name=m.join(\"\")}if(0<(b.h&16)){m=[];for(l=0;0<(k=g[h++]);)m[l++]=String.fromCharCode(k);b.J=m.join(\"\")}0<(b.h&2)&&(b.B=B(g,0,h)&65535,b.B!==(g[h++]|g[h++]<<8)&&n(Error(\"invalid header crc16\")));d=g[g.length-4]|g[g.length-3]<<8|g[g.length-2]<<16|g[g.length-1]<<24;g.length-h-4-4<512*d&&(f=d);c=new L(g,{index:h,bufferSize:f});b.data=a=c.g();h=c.c;b.K=q=(g[h++]|g[h++]<<8|g[h++]<<16|g[h++]<<24)>>>0;B(a,p,p)!==q&&n(Error(\"invalid CRC-32 checksum: 0x\"+B(a,p,p).toString(16)+\" / 0x\"+q.toString(16)));b.L=\nd=(g[h++]|g[h++]<<8|g[h++]<<16|g[h++]<<24)>>>0;(a.length&4294967295)!==d&&n(Error(\"invalid input size: \"+(a.length&4294967295)+\" / \"+d));this.m.push(b);this.c=h}this.s=!0;var v=this.m,s,F,H=0,w=0,z;s=0;for(F=v.length;s<F;++s)w+=v[s].data.length;if(x){z=new Uint8Array(w);for(s=0;s<F;++s)z.set(v[s].data,H),H+=v[s].data.length}else{z=[];for(s=0;s<F;++s)z[s]=v[s].data;z=Array.prototype.concat.apply([],z)}return z};t(\"Zlib.Gunzip\",$);t(\"Zlib.Gunzip.prototype.decompress\",$.prototype.g);t(\"Zlib.Gunzip.prototype.getMembers\",$.prototype.F);t(\"Zlib.GunzipMember\",E);t(\"Zlib.GunzipMember.prototype.getName\",E.prototype.getName);t(\"Zlib.GunzipMember.prototype.getData\",E.prototype.getData);t(\"Zlib.GunzipMember.prototype.getMtime\",E.prototype.G);}).call(this);\n\n\n//# sourceURL=webpack://VGM/./node_modules/zlibjs/bin/gunzip.min.js?");

/***/ })

/******/ })["VGM"];